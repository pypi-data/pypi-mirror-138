<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.common.io API documentation</title>
<meta name="description" content="This module provides IO primitives for working with cross-API RedVox data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.io</code></h1>
</header>
<section id="section-intro">
<p>This module provides IO primitives for working with cross-API RedVox data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides IO primitives for working with cross-API RedVox data.
&#34;&#34;&#34;
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from glob import glob
import json
import os.path
import multiprocessing
import multiprocessing.pool
import tempfile
from pathlib import Path, PurePath
from shutil import copy2, move, rmtree
from typing import (
    Any,
    Dict,
    Iterator,
    List,
    Optional,
    Set,
    Union,
    TYPE_CHECKING,
    Callable,
)

import lz4.frame

from redvox.api900.reader import read_rdvxz_file, read_buffer
from redvox.api1000.common.common import check_type
from redvox.api1000.wrapped_redvox_packet.wrapped_packet import WrappedRedvoxPacketM
from redvox.api1000.proto.redvox_api_m_pb2 import RedvoxPacketM
from redvox.common.versioning import check_version, ApiVersion
from redvox.common.date_time_utils import (
    datetime_from_epoch_microseconds_utc as dt_us,
    datetime_from_epoch_milliseconds_utc as dt_ms,
    datetime_to_epoch_microseconds_utc as us_dt,
    truncate_dt_ymd,
    truncate_dt_ymdh,
)
from redvox.common.parallel_utils import maybe_parallel_map

if TYPE_CHECKING:
    from redvox.api900.wrapped_redvox_packet import WrappedRedvoxPacket
    from redvox.api900.lib.api900_pb2 import RedvoxPacket


class FileSystemWriter:
    &#34;&#34;&#34;
    This class holds basic information about writing and reading objects from a file system
    If user does not enable saving to disk, we use a temporary directory to store large files

    Properties:
        file_name: str, the name of the file (do not include extension)
        file_ext: str, the extension used by the file (do not include the .).  Default &#34;NONE&#34;
        base_dir: str, the directory to save the file to.  Default &#34;.&#34; (current dir)
        save_to_disk: bool, if True, save data to disk.  Default False

    Protected:
        _temp_dir: TemporaryDirectory, temporary directory for large files when not saving to disk
    &#34;&#34;&#34;

    def __init__(self, file_name: str, file_ext: str = &#34;none&#34;,
                 base_dir: str = &#34;.&#34;, save_enabled: bool = False):
        &#34;&#34;&#34;
        initialize FileSystemWriter

        :param file_name: name of file
        :param file_ext: extension of file, default &#34;none&#34;
        :param base_dir: directory to save file to, default &#34;.&#34; (current dir)
        :param save_enabled: if True, save to the file specified by, default False
        &#34;&#34;&#34;
        self.file_name: str = file_name
        self.file_extension: str = file_ext.lower()
        self.save_to_disk: bool = save_enabled
        self.base_dir: str = base_dir
        self._temp_dir = tempfile.TemporaryDirectory()

    def save_dir(self) -&gt; str:
        &#34;&#34;&#34;
        :return: directory where file would be saved based on current value of self.save_to_disk
        &#34;&#34;&#34;
        return self.base_dir if self.save_to_disk else self._temp_dir.name

    def full_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name with extension
        &#34;&#34;&#34;
        return f&#34;{self.file_name}.{self.file_extension}&#34;

    def full_path(self) -&gt; str:
        &#34;&#34;&#34;
        :return: the full path to where the file would be written
        &#34;&#34;&#34;
        return os.path.join(self.save_dir(), self.full_name())

    def set_name_and_extension(self, name: str, ext: str):
        &#34;&#34;&#34;
        set the name and extension of the output file.  Do not include the . for the extension
        :param name: file name
        :param ext: file extension
        &#34;&#34;&#34;
        self.file_name = name
        self.file_extension = ext

    def json_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name with .json extension
        &#34;&#34;&#34;
        return f&#34;{self.file_name}.json&#34;

    def json_path(self) -&gt; Path:
        &#34;&#34;&#34;
        :return: full path to json file
        &#34;&#34;&#34;
        return Path(self.save_dir()).joinpath(self.json_file_name())

    def create_dir(self):
        &#34;&#34;&#34;
        if saving to disk, otherwise remove any files in the directory,
        then create the directory if it doesn&#39;t exist
        &#34;&#34;&#34;
        if self.save_to_disk:
            if os.path.exists(self.save_dir()):
                rmtree(self.save_dir())
            os.makedirs(self.save_dir(), exist_ok=True)

    def __del__(self):
        &#34;&#34;&#34;
        remove temp dir
        &#34;&#34;&#34;
        self._temp_dir.cleanup()

    def as_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: FileSystemWriter as dictionary
        &#34;&#34;&#34;
        return {
            &#34;file_name&#34;: self.file_name,
            &#34;file_extension&#34;: self.file_extension,
            &#34;base_dir&#34;: self.base_dir,
            &#34;save_to_disk&#34;: self.save_to_disk
        }


def json_to_dict(json_str: str) -&gt; Dict:
    &#34;&#34;&#34;
    :param json_str: string of json to convert to dictionary
    :return: json string as a dictionary
    &#34;&#34;&#34;
    return json.loads(json_str)


def json_file_to_dict(file_path: str) -&gt; Dict:
    &#34;&#34;&#34;
    :param file_path: full path of file to load data from.
    :return: json file as python dictionary
    &#34;&#34;&#34;
    with open(file_path, &#34;r&#34;) as f_p:
        return json_to_dict(f_p.read())


def get_json_file(file_dir: str) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Finds the first json file in the file_dir specified or None if there is no file

    :param file_dir: directory to find json file in
    :return: full name of first json file in the directory or None if no files found
    &#34;&#34;&#34;
    file_names = glob(os.path.join(file_dir, &#34;*.json&#34;))
    if len(file_names) &lt; 1:
        return None
    return Path(file_names[0]).name


def _is_int(value: str) -&gt; Optional[int]:
    &#34;&#34;&#34;
    Tests if a given str is a valid integer. If it is, the integer is returned, if it is not, None is returned.

    :param value: The string to test.
    :return: The integer value if it is valid, or None if it is not valid.
    &#34;&#34;&#34;
    try:
        return int(value)
    except ValueError:
        return None


def _not_none(value: Optional[Any]) -&gt; bool:
    &#34;&#34;&#34;
    Tests that the given value is not None.

    :param value: The value to test.
    :return: True if the value is not None, False if it is None.
    &#34;&#34;&#34;
    return value is not None


@dataclass
class IndexEntry:
    &#34;&#34;&#34;
    This class represents a single index entry. It extracts and encapsulated API agnostic fields that represent the
    information stored in standard RedVox file names.
    &#34;&#34;&#34;

    full_path: str
    station_id: str
    date_time: datetime
    extension: str
    api_version: ApiVersion

    @staticmethod
    def from_path(path_str: str, strict: bool = True) -&gt; Optional[&#34;IndexEntry&#34;]:
        &#34;&#34;&#34;
        Attempts to parse a file path into an IndexEntry. If a given path is not recognized as a valid RedVox file,
        None will be returned instead.

        :param path_str: The file system path to attempt to parse.
        :param strict: When set, None is returned if the referenced file DNE.
        :return: Either an IndexEntry or successful parse or None.
        &#34;&#34;&#34;
        api_version: ApiVersion = check_version(path_str)
        path: Path = Path(path_str)
        name: str = path.stem
        ext: str = path.suffix

        # Attempt to parse file name parts
        split_name = name.split(&#34;_&#34;)
        if len(split_name) != 2:
            return None

        station_id: str = split_name[0]
        ts_str: str = split_name[1]

        # If you have a filename with a dot, but not an extension, i.e. &#34;0000000001_0.&#34;, we need to remove the dot
        # from the end and make in the extension
        if len(ts_str) &gt; 0 and ts_str[-1] == &#34;.&#34;:
            ts_str = ts_str[:-1]
            ext = &#34;.&#34;

        timestamp: Optional[int] = _is_int(ts_str)

        # Ensure that both the station ID and timestamp can be represented as ints
        if _is_int(station_id) is None or timestamp is None:
            return None

        # Parse the datetime per the specified API version
        date_time: datetime
        if api_version == ApiVersion.API_1000:
            date_time = dt_us(timestamp)
        else:
            date_time = dt_ms(timestamp)

        full_path: str
        try:
            full_path = str(path.resolve(strict=True))
        except FileNotFoundError:
            if strict:
                return None
            full_path = path_str

        return IndexEntry(full_path, station_id, date_time, ext, api_version)

    @staticmethod
    def from_native(entry) -&gt; &#34;IndexEntry&#34;:
        &#34;&#34;&#34;
        Converts a native index entry into a python index entry.

        :param entry: A native index entry.
        :return: A python index entry.
        &#34;&#34;&#34;
        return IndexEntry(
            entry.full_path,
            entry.station_id,
            dt_us(entry.date_time),
            entry.extension,
            ApiVersion.from_str(entry.api_version),
        )

    def to_native(self):
        import redvox_native

        entry = redvox_native.IndexEntry(
            self.full_path,
            self.station_id,
            us_dt(self.date_time),
            self.extension,
            self.api_version.value,
        )
        return entry

    def read(self) -&gt; Optional[Union[WrappedRedvoxPacketM, &#34;WrappedRedvoxPacket&#34;]]:
        &#34;&#34;&#34;
        Reads, decompresses, deserializes, and wraps the RedVox file pointed to by this entry.

        :return: One of WrappedRedvoxPacket, WrappedRedvoxPacketM, or None.
        &#34;&#34;&#34;
        if self.api_version == ApiVersion.API_900:
            return read_rdvxz_file(self.full_path)
        elif self.api_version == ApiVersion.API_1000:
            return WrappedRedvoxPacketM.from_compressed_path(self.full_path)
        else:
            return None

    def read_raw(self) -&gt; Optional[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
        &#34;&#34;&#34;
        Reads, decompresses, and deserializes the RedVox file pointed to by this entry.

        :return: One of RedvoxPacket, RedvoxPacketM, or None. Note that these are the raw protobuf types.
        &#34;&#34;&#34;
        if self.api_version == ApiVersion.API_900:
            with open(self.full_path, &#34;rb&#34;) as buf_in:
                return read_buffer(buf_in.read())
        elif self.api_version == ApiVersion.API_1000:
            with lz4.frame.open(self.full_path, &#34;rb&#34;) as serialized_in:
                proto: RedvoxPacketM = RedvoxPacketM()
                proto.ParseFromString(serialized_in.read())
                return proto
        else:
            return None

    def _into_native(self):
        pass

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;
        Tests if this value is equal to another value.
        This along with __lt__ are used to fulfill the total ordering contract. Compares this entry&#39;s full path to
        another entries full path.

        :param other: Other IndexEntry to compare against.
        :return: True if this full path is less than the other full path.
        &#34;&#34;&#34;
        if isinstance(other, IndexEntry):
            return self.full_path == other.full_path

        return False


# noinspection DuplicatedCode
@dataclass
class ReadFilter:
    &#34;&#34;&#34;
    Filter RedVox files from the file system.
    &#34;&#34;&#34;

    start_dt: Optional[datetime] = None
    end_dt: Optional[datetime] = None
    station_ids: Optional[Set[str]] = None
    extensions: Optional[Set[str]] = field(default_factory=lambda: {&#34;.rdvxm&#34;, &#34;.rdvxz&#34;})
    start_dt_buf: Optional[timedelta] = timedelta(minutes=2.0)
    end_dt_buf: Optional[timedelta] = timedelta(minutes=2.0)
    api_versions: Optional[Set[ApiVersion]] = field(
        default_factory=lambda: {ApiVersion.API_900, ApiVersion.API_1000}
    )

    @staticmethod
    def empty() -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        :return: A ReadFilter with ALL filters set to None. This is opposed to the default
                 which sets sane defaults for extensions, APIs, and window buffers.
        &#34;&#34;&#34;
        return ReadFilter(None, None, None, None, None, None, None)

    def clone(self) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        :return: a copy of the calling ReadFilter
        &#34;&#34;&#34;
        return_filter = ReadFilter()
        return (
            return_filter.with_start_dt(self.start_dt)
            .with_end_dt(self.end_dt)
            .with_station_ids(self.station_ids)
            .with_extensions(self.extensions)
            .with_start_dt_buf(self.start_dt_buf)
            .with_end_dt_buf(self.end_dt_buf)
            .with_api_versions(self.api_versions)
        )

    def with_start_dt(self, start_dt: Optional[datetime]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Adds a start datetime filter.

        :param start_dt: Start datetime that files should come after.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(start_dt, [datetime, None])
        self.start_dt = start_dt
        return self

    def with_start_ts(self, start_ts: Optional[float]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Adds a start time filter.

        :param start_ts: Start timestamp (microseconds)
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(start_ts, [int, float, None])
        if start_ts is None:
            return self.with_start_dt(None)

        return self.with_start_dt(dt_us(start_ts))

    def with_end_dt(self, end_dt: Optional[datetime]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Adds an end datetime filter.

        :param end_dt: Filter for which packets should come before.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(end_dt, [datetime, None])
        self.end_dt = end_dt
        return self

    def with_end_ts(self, end_ts: Optional[float]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Like with_end_dt, but uses a microsecond timestamp.

        :param end_ts: Timestamp microseconds.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(end_ts, [int, float, None])
        if end_ts is None:
            return self.with_end_dt(None)

        return self.with_end_dt(dt_us(end_ts))

    def with_station_ids(self, station_ids: Optional[Set[str]]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Add a station id filter. Filters against provided station ids.

        :param station_ids: Station ids to filter against.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(station_ids, [set, None])
        self.station_ids = station_ids
        return self

    def with_extensions(self, extensions: Optional[Set[str]]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Filters against known file extensions.

        :param extensions: One or more extensions to filter against
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(extensions, [set, None])
        self.extensions = extensions
        return self

    def with_start_dt_buf(self, start_dt_buf: Optional[timedelta]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Modifies the time buffer prepended to the start time.

        :param start_dt_buf: Amount of time to buffer before start time.
        :return: A modified instance of self.
        &#34;&#34;&#34;
        check_type(start_dt_buf, [timedelta, None])
        self.start_dt_buf = start_dt_buf
        return self

    def with_end_dt_buf(self, end_dt_buf: Optional[timedelta]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Modifies the time buffer appended to the end time.

        :param end_dt_buf: Amount of time to buffer after end time.
        :return: A modified instance of self.
        &#34;&#34;&#34;
        check_type(end_dt_buf, [timedelta, None])
        self.end_dt_buf = end_dt_buf
        return self

    def with_api_versions(
        self, api_versions: Optional[Set[ApiVersion]]
    ) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Filters for specified API versions.

        :param api_versions: A set containing valid ApiVersion enums that should be included.
        :return: A modified instance of self.
        &#34;&#34;&#34;
        check_type(api_versions, [set, None])
        self.api_versions = api_versions
        return self

    def apply_dt(
        self, date_time: datetime, dt_fn: Callable[[datetime], datetime] = lambda dt: dt
    ) -&gt; bool:
        &#34;&#34;&#34;
        Tests if a given datetime passes this filter.

        :param date_time: Datetime to test
        :param dt_fn: An (optional) function that will transform one datetime into another.
        :return: True if the datetime is included, False otherwise
        &#34;&#34;&#34;
        check_type(date_time, [datetime])
        start_buf: timedelta = (
            timedelta(seconds=0) if self.start_dt_buf is None else self.start_dt_buf
        )
        if self.start_dt is not None and date_time &lt; (dt_fn(self.start_dt - start_buf)):
            return False

        end_buf: timedelta = (
            timedelta(seconds=0) if self.end_dt_buf is None else self.end_dt_buf
        )
        if self.end_dt is not None and date_time &gt; (dt_fn(self.end_dt + end_buf)):
            return False

        return True

    def apply(self, entry: IndexEntry) -&gt; bool:
        &#34;&#34;&#34;
        Applies this filter to the given IndexEntry.

        :param entry: The entry to test.
        :return: True if the entry is accepted by the filter, False otherwise.
        &#34;&#34;&#34;
        check_type(entry, [IndexEntry])

        if not self.apply_dt(entry.date_time):
            return False

        if self.station_ids is not None and entry.station_id not in self.station_ids:
            return False

        if self.extensions is not None and entry.extension not in self.extensions:
            return False

        if self.api_versions is not None and entry.api_version not in self.api_versions:
            return False

        return True


@dataclass
class IndexStationSummary:
    &#34;&#34;&#34;
    Summary of a single station in the index.
    &#34;&#34;&#34;

    station_id: str
    api_version: ApiVersion
    total_packets: int
    first_packet: datetime
    last_packet: datetime

    @staticmethod
    def from_entry(entry: IndexEntry) -&gt; &#34;IndexStationSummary&#34;:
        &#34;&#34;&#34;
        Instantiates a new summary from a given IndexEntry.

        :param entry: Entry to copy information from.
        :return: An instance of IndexStationSummary.
        &#34;&#34;&#34;
        return IndexStationSummary(
            entry.station_id,
            entry.api_version,
            1,
            first_packet=entry.date_time,
            last_packet=entry.date_time,
        )

    def update(self, entry: IndexEntry) -&gt; None:
        &#34;&#34;&#34;
        Updates this summary given a new index entry.

        :param entry: Entry to update this summary from.
        &#34;&#34;&#34;
        self.total_packets += 1
        if entry.date_time &lt; self.first_packet:
            self.first_packet = entry.date_time

        if entry.date_time &gt; self.last_packet:
            self.last_packet = entry.date_time


@dataclass
class IndexSummary:
    &#34;&#34;&#34;
    Summarizes the contents of the index.
    &#34;&#34;&#34;

    station_summaries: Dict[ApiVersion, Dict[str, IndexStationSummary]]

    def station_ids(self, api_version: ApiVersion = None) -&gt; List[str]:
        &#34;&#34;&#34;
        Returns the station IDs referenced by this index.

        :param api_version: An (optional) filter to only return packets for a specified RedVox API version.
                            None will collect station IDs from all API versions.
        :return: The station IDs referenced by this index.
        &#34;&#34;&#34;
        if api_version is not None:
            return list(
                set(
                    map(
                        lambda summary: summary.station_id,
                        self.station_summaries[api_version].values(),
                    )
                )
            )
        else:
            # noinspection PyTypeChecker
            return list(
                set(
                    map(
                        lambda summary: summary.station_id,
                        self.station_summaries[ApiVersion.API_900].values(),
                    )
                )
            ) + list(
                set(
                    map(
                        lambda summary: summary.station_id,
                        self.station_summaries[ApiVersion.API_1000].values(),
                    )
                )
            )

    def total_packets(self, api_version: ApiVersion = None) -&gt; int:
        &#34;&#34;&#34;
        Returns the total number of packets referenced by this index.

        :param api_version: An (optional) filter to only return packets for a specified RedVox API version.
                            None will count packets from all API versions.
        :return: The total number of packets referenced by this index.
        &#34;&#34;&#34;
        if api_version is not None:
            return sum(
                map(
                    lambda summary: summary.total_packets,
                    self.station_summaries[api_version].values(),
                )
            )
        else:
            # noinspection PyTypeChecker
            return sum(
                map(
                    lambda summary: summary.total_packets,
                    self.station_summaries[ApiVersion.API_900].values(),
                )
            ) + sum(
                map(
                    lambda summary: summary.total_packets,
                    self.station_summaries[ApiVersion.API_1000].values(),
                )
            )

    @staticmethod
    def from_index(index: &#34;Index&#34;) -&gt; &#34;IndexSummary&#34;:
        &#34;&#34;&#34;
        Builds an IndexSummary from a given index.

        :param index: Index to build summary from.
        :return: An instance of IndexSummary.
        &#34;&#34;&#34;
        station_summaries: Dict[
            ApiVersion, Dict[str, IndexStationSummary]
        ] = defaultdict(dict)

        entry: IndexEntry
        for entry in index.entries:
            sub_entry: Dict[str, IndexStationSummary] = station_summaries[
                entry.api_version
            ]
            if entry.station_id in sub_entry:
                # Update existing station summary
                sub_entry[entry.station_id].update(entry)
            else:
                # Create new station summary
                sub_entry[entry.station_id] = IndexStationSummary.from_entry(entry)

        return IndexSummary(station_summaries)


@dataclass
class Index:
    &#34;&#34;&#34;
    An index of available RedVox files from the file system.
    &#34;&#34;&#34;

    entries: List[IndexEntry] = field(default_factory=lambda: [])

    @staticmethod
    def from_native(index_native) -&gt; &#34;Index&#34;:
        &#34;&#34;&#34;
        Converts a native index into a python index.

        :param index_native: A native index.
        :return: A Python index.
        &#34;&#34;&#34;
        entries: List[IndexEntry] = list(
            map(IndexEntry.from_native, index_native.entries)
        )
        return Index(entries)

    def to_native(self):
        import redvox_native

        native_index = redvox_native.Index()
        native_index.entries = list(map(IndexEntry.to_native, self.entries))
        return native_index

    def sort(self) -&gt; None:
        &#34;&#34;&#34;
        Sorts the entries stored in this index.
        &#34;&#34;&#34;
        self.entries = sorted(
            self.entries,
            key=lambda entry: (entry.api_version, entry.station_id, entry.date_time),
        )

    def append(self, entries: Iterator[IndexEntry]) -&gt; None:
        &#34;&#34;&#34;
        Appends new entries to this index.

        :param entries: Entries to append.
        &#34;&#34;&#34;
        self.entries.extend(entries)

    def summarize(self) -&gt; IndexSummary:
        &#34;&#34;&#34;
        :return: A summary of the contents of this index.
        &#34;&#34;&#34;
        return IndexSummary.from_index(self)

    def get_index_for_station_id(self, station_id: str) -&gt; &#34;Index&#34;:
        &#34;&#34;&#34;
        :param station_id: id to get entries for
        :return: Index containing only the entries for the station requested
        &#34;&#34;&#34;
        return Index([en for en in self.entries if en.station_id == station_id])

    def stream_raw(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; Iterator[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, deserialize, and then stream RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be streamed.
        :return: An iterator over RedvoxPacket and RedvoxPacketM instances.
        &#34;&#34;&#34;
        filtered: Iterator[IndexEntry] = filter(read_filter.apply, self.entries)
        # noinspection Mypy
        return map(IndexEntry.read_raw, filtered)

    def stream(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; Iterator[Union[&#34;WrappedRedvoxPacket&#34;, WrappedRedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, deserialize, wrap, and then stream RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be streamed.
        :return: An iterator over WrappedRedvoxPacket and WrappedRedvoxPacketM instances.
        &#34;&#34;&#34;
        filtered: Iterator[IndexEntry] = filter(read_filter.apply, self.entries)
        # noinspection Mypy
        return map(IndexEntry.read, filtered)

    def read_raw(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; List[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, and deserialize RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be read.
        :return: An list of RedvoxPacket and RedvoxPacketM instances.
        &#34;&#34;&#34;
        return list(self.stream_raw(read_filter))

    def read(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; List[Union[&#34;WrappedRedvoxPacket&#34;, WrappedRedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, deserialize, and wrap RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be read.
        :return: An list of WrappedRedvoxPacket and WrappedRedvoxPacketM instances.
        &#34;&#34;&#34;
        return list(self.stream(read_filter))


# The following constants are used for identifying valid RedVox API 900 and API 1000 structured directory layouts.
__VALID_YEARS: Set[str] = {f&#34;{i:04}&#34; for i in range(2015, 2031)}
__VALID_MONTHS: Set[str] = {f&#34;{i:02}&#34; for i in range(1, 13)}
__VALID_DATES: Set[str] = {f&#34;{i:02}&#34; for i in range(1, 32)}
__VALID_HOURS: Set[str] = {f&#34;{i:02}&#34; for i in range(0, 24)}


def _list_subdirs(base_dir: str, valid_choices: Set[str]) -&gt; Iterator[str]:
    &#34;&#34;&#34;
    Lists sub-directors in a given base directory that match the provided choices.

    :param base_dir: Base dir to find sub dirs in.
    :param valid_choices: A list of valid directory names.
    :return: A list of valid subdirs.
    &#34;&#34;&#34;
    subdirs: Iterator[str] = map(
        lambda p: PurePath(p).name, glob(os.path.join(base_dir, &#34;*&#34;, &#34;&#34;))
    )
    return filter(valid_choices.__contains__, subdirs)


# These fields are set at runtime and provide the implementation (either native or pure python) for IO methods
__INDEX_STRUCTURED_FN: Callable[
    [str, ReadFilter, Optional[multiprocessing.pool.Pool]], Index
]
__INDEX_STRUCTURED_900_FN: Callable[
    [str, ReadFilter, bool, Optional[multiprocessing.pool.Pool]], Index
]
__INDEX_STRUCTURED_1000_FN: Callable[
    [str, ReadFilter, bool, Optional[multiprocessing.pool.Pool]], Index
]
__INDEX_UNSTRUCTURED_FN: Callable[
    [str, ReadFilter, bool, Optional[multiprocessing.pool.Pool]], Index
]


def __map_opt(fn, v):
    &#34;&#34;&#34;
    Maps the provided function on the value if v is not None, otherwise, returns None.

    :param fn: The mapping function.
    :param v: The optional value to map.
    :return: The optional mapped value.
    &#34;&#34;&#34;
    if v is None:
        return None
    return fn(v)


def __dur2us(dur: timedelta) -&gt; float:
    &#34;&#34;&#34;
    Converts a timedelta into microseconds.

    :param dur: timedelta to convert
    :return: Number of microseconds in the time delta.
    &#34;&#34;&#34;
    return dur.total_seconds() * 1_000_000.0


def __api_native(apis_py: Set[ApiVersion]) -&gt; Set[str]:
    &#34;&#34;&#34;
    Convert python ApiVersions into native ApiVersions.

    :param apis_py: Python API versions.
    :return: Native API versions.
    &#34;&#34;&#34;
    r: Set[str] = set()
    for api_py in apis_py:
        if api_py == ApiVersion.API_900:
            r.add(&#34;Api900&#34;)
            continue
        if api_py == ApiVersion.API_1000:
            r.add(&#34;Api1000&#34;)

    return r


def index_unstructured_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Returns the list of file paths that match the given filter for unstructured data.

    :param base_dir: Directory containing unstructured data.
    :param read_filter: An (optional) ReadFilter for specifying station IDs and time windows.
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: An iterator of valid paths.
    &#34;&#34;&#34;
    check_type(base_dir, [str])
    check_type(read_filter, [ReadFilter])

    index: Index = Index()

    extensions: Set[str] = (
        read_filter.extensions if read_filter.extensions is not None else {&#34;&#34;}
    )

    all_paths: List[str] = []

    extension: str
    for extension in extensions:
        pattern: str = str(PurePath(base_dir).joinpath(f&#34;*{extension}&#34;))
        paths: List[str] = glob(os.path.join(base_dir, pattern))
        all_paths.extend(paths)

    all_entries: Iterator[Optional[IndexEntry]] = maybe_parallel_map(
        pool,
        IndexEntry.from_path,
        iter(all_paths),
        lambda: len(all_paths) &gt; 128,
        chunk_size=64,
    )

    # if len(all_paths) &gt; 128:
    #     _pool: multiprocessing.pool.Pool = (
    #         multiprocessing.Pool() if pool is None else pool
    #     )
    #     all_entries = _pool.imap(IndexEntry.from_path, iter(all_paths))
    #     if pool is None:
    #         _pool.close()
    # else:
    #     all_entries = map(IndexEntry.from_path, all_paths)

    entries: Iterator[IndexEntry] = filter(
        read_filter.apply, filter(_not_none, all_entries)
    )

    index.append(entries)

    if sort:
        index.sort()

    return index


def index_structured_api_900_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API 900 directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api900)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    index: Index = Index()

    _pool: multiprocessing.pool.Pool = multiprocessing.Pool() if pool is None else pool

    for year in _list_subdirs(base_dir, __VALID_YEARS):
        for month in _list_subdirs(os.path.join(base_dir, year), __VALID_MONTHS):
            for day in _list_subdirs(
                os.path.join(base_dir, year, month), __VALID_DATES
            ):
                # Before scanning for *.rdvxz files, let&#39;s see if the current year, month, day, are in the
                # filter&#39;s range. If not, we can short circuit and skip getting the *.rdvxz files.
                if not read_filter.apply_dt(
                    datetime(int(year), int(month), int(day)), dt_fn=truncate_dt_ymd
                ):
                    continue

                data_dir: str = os.path.join(base_dir, year, month, day)
                entries: Iterator[IndexEntry] = iter(
                    index_unstructured_py(
                        data_dir, read_filter, sort=False, pool=_pool
                    ).entries
                )
                index.append(entries)

    if pool is None:
        _pool.close()

    if sort:
        index.sort()
    return index


def index_structured_api_1000_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API M directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api1000)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    index: Index = Index()

    _pool: multiprocessing.pool.Pool = multiprocessing.Pool() if pool is None else pool

    for year in _list_subdirs(base_dir, __VALID_YEARS):
        for month in _list_subdirs(os.path.join(base_dir, year), __VALID_MONTHS):
            for day in _list_subdirs(
                os.path.join(base_dir, year, month), __VALID_DATES
            ):
                for hour in _list_subdirs(
                    os.path.join(base_dir, year, month, day), __VALID_HOURS
                ):
                    # Before scanning for *.rdvxm files, let&#39;s see if the current year, month, day, hour are in the
                    # filter&#39;s range. If not, we can short circuit and skip getting the *.rdvxm files.
                    if not read_filter.apply_dt(
                        datetime(int(year), int(month), int(day), int(hour)),
                        dt_fn=truncate_dt_ymdh,
                    ):
                        continue

                    data_dir: str = os.path.join(base_dir, year, month, day, hour)
                    entries: Iterator[IndexEntry] = iter(
                        index_unstructured_py(
                            data_dir, read_filter, sort=False, pool=_pool
                        ).entries
                    )
                    index.append(entries)

    if pool is None:
        _pool.close()

    if sort:
        index.sort()
    return index


def index_structured_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Indexes both API 900 and API 1000 structured directory layouts.

    :param base_dir: The base_dir may either end with api900, api1000, or be a parent directory to one or both of
                     API 900 and API 1000.
    :param read_filter: Filter to further filter results.
    :param pool: Pool for multiprocessing
    :return: An Index of RedVox files.
    &#34;&#34;&#34;
    base_path: PurePath = PurePath(base_dir)

    _pool: multiprocessing.pool.Pool = multiprocessing.Pool() if pool is None else pool

    # API 900
    if base_path.name == &#34;api900&#34;:
        return index_structured_api_900_py(base_dir, read_filter, pool=_pool)
    # API 1000
    elif base_path.name == &#34;api1000&#34;:
        return index_structured_api_1000_py(base_dir, read_filter, pool=_pool)
    # Maybe parent to one or both?
    else:
        index: Index = Index()
        subdirs: List[str] = list(_list_subdirs(base_dir, {&#34;api900&#34;, &#34;api1000&#34;}))
        if &#34;api900&#34; in subdirs:
            index.append(
                iter(
                    index_structured_api_900_py(
                        str(base_path.joinpath(&#34;api900&#34;)),
                        read_filter,
                        sort=False,
                        pool=_pool,
                    ).entries
                )
            )

        if &#34;api1000&#34; in subdirs:
            index.append(
                iter(
                    index_structured_api_1000_py(
                        str(base_path.joinpath(&#34;api1000&#34;)),
                        read_filter,
                        sort=False,
                        pool=_pool,
                    ).entries
                )
            )

        if pool is None:
            _pool.close()

        index.sort()
        return index


# Here we try to import the redvox_native module which provides natively compiled io functions.
# This dynamically sets which functions are called at runtime. Either the native version (if found)
# or the pure Python version.
try:
    # noinspection PyUnresolvedReferences
    import redvox_native

    def __into_read_filter_native(read_filter: ReadFilter):
        &#34;&#34;&#34;
        Converts a python read filter into a native read filter.

        :param read_filter: Python read filter to convert.
        :return: A native read filter.
        &#34;&#34;&#34;
        read_filter_native = redvox_native.ReadFilter()
        read_filter_native.start_dt = __map_opt(us_dt, read_filter.start_dt)
        read_filter_native.end_dt = __map_opt(us_dt, read_filter.end_dt)
        read_filter_native.start_dt_buf = __map_opt(__dur2us, read_filter.start_dt_buf)
        read_filter_native.end_dt_buf = __map_opt(__dur2us, read_filter.end_dt_buf)
        read_filter_native.station_ids = read_filter.station_ids
        read_filter_native.extensions = read_filter.extensions
        read_filter_native.api_versions = __map_opt(
            __api_native, read_filter.api_versions
        )

        return read_filter_native

    def __index_structured_900_native(
        base_dir: str,
        read_filter: ReadFilter,
        sort: bool,
        pool: Optional[multiprocessing.pool.Pool],
    ) -&gt; Index:
        &#34;&#34;&#34;
        This parses a structured API 900 directory structure and identifies files that match the provided filter.

        :param base_dir: Base directory (should be named api900)
        :param read_filter: Filter to filter files with
        :param sort: When True, the resulting Index will be sorted before being returned (default=True).
        :param pool: Pool for multiprocessing (not used in native)
        :return: A list of wrapped packets on an empty list if none match the filter or none are found
        &#34;&#34;&#34;
        read_filter = __into_read_filter_native(read_filter)
        return Index.from_native(
            redvox_native.index_structured_900(base_dir, read_filter, sort)
        )

    def __index_structured_1000_native(
        base_dir: str,
        read_filter: ReadFilter,
        sort: bool,
        pool: Optional[multiprocessing.pool.Pool],
    ) -&gt; Index:
        &#34;&#34;&#34;
        This parses a structured API M directory structure and identifies files that match the provided filter.

        :param base_dir: Base directory (should be named api1000)
        :param read_filter: Filter to filter files with
        :param sort: When True, the resulting Index will be sorted before being returned (default=True).
        :param pool: Pool for multiprocessing (not used in native)
        :return: A list of wrapped packets on an empty list if none match the filter or none are found
        &#34;&#34;&#34;
        read_filter = __into_read_filter_native(read_filter)
        return Index.from_native(
            redvox_native.index_structured_1000(base_dir, read_filter, sort)
        )

    def __index_structured_native(
        base_dir: str,
        read_filter: ReadFilter,
        pool: Optional[multiprocessing.pool.Pool],
    ) -&gt; Index:
        &#34;&#34;&#34;
        Indexes both API 900 and API 1000 structured directory layouts.

        :param base_dir: The base_dir may either end with api900, api1000, or be a parent directory to one or both of
                         API 900 and API 1000.
        :param read_filter: Filter to further filter results.
        :param pool: Pool for multiprocessing (not used in native)
        :return: An Index of RedVox files.
        &#34;&#34;&#34;
        read_filter = __into_read_filter_native(read_filter)
        return Index.from_native(redvox_native.index_structured(base_dir, read_filter))

    def __index_unstructured_native(
        base_dir: str,
        read_filter: ReadFilter,
        sort: bool,
        pool: Optional[multiprocessing.pool.Pool],
    ) -&gt; Index:
        &#34;&#34;&#34;
        Returns the list of file paths that match the given filter for unstructured data.

        :param base_dir: Directory containing unstructured data.
        :param read_filter: An (optional) ReadFilter for specifying station IDs and time windows.
        :param sort: When True, the resulting Index will be sorted before being returned (default=True).
        :param pool: Pool for multiprocessing (not used in native implementation)
        :return: An iterator of valid paths.
        &#34;&#34;&#34;
        read_filter = __into_read_filter_native(read_filter)
        return Index.from_native(
            redvox_native.index_unstructured(base_dir, read_filter, sort)
        )

    __INDEX_STRUCTURED_FN = __index_structured_native
    __INDEX_STRUCTURED_900_FN = __index_structured_900_native
    __INDEX_STRUCTURED_1000_FN = __index_structured_1000_native
    __INDEX_UNSTRUCTURED_FN = __index_unstructured_native
except ImportError:
    __INDEX_STRUCTURED_900_FN = index_structured_api_900_py
    __INDEX_STRUCTURED_1000_FN = index_structured_api_1000_py
    __INDEX_STRUCTURED_FN = index_structured_py
    __INDEX_UNSTRUCTURED_FN = index_unstructured_py


def index_unstructured(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Returns the list of file paths that match the given filter for unstructured data.

    :param base_dir: Directory containing unstructured data.
    :param read_filter: An (optional) ReadFilter for specifying station IDs and time windows.
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: An iterator of valid paths.
    &#34;&#34;&#34;
    return __INDEX_UNSTRUCTURED_FN(base_dir, read_filter, sort, pool)


def index_structured_api_900(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API 900 directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api900)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    return __INDEX_STRUCTURED_900_FN(base_dir, read_filter, sort, pool)


def index_structured_api_1000(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API M directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api1000)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    return __INDEX_STRUCTURED_1000_FN(base_dir, read_filter, sort, pool)


def index_structured(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Indexes both API 900 and API 1000 structured directory layouts.

    :param base_dir: The base_dir may either end with api900, api1000, or be a parent directory to one or both of
                     API 900 and API 1000.
    :param read_filter: Filter to further filter results.
    :param pool: Pool for multiprocessing
    :return: An Index of RedVox files.
    &#34;&#34;&#34;
    return __INDEX_STRUCTURED_FN(base_dir, read_filter, pool)


def sort_unstructured_redvox_data(
    input_dir: str,
    output_dir: Optional[str] = None,
    read_filter: ReadFilter = ReadFilter(),
    copy: bool = True,
) -&gt; bool:
    &#34;&#34;&#34;
    takes all redvox files in input_dir and sorts them into appropriate sub-directories

    :param input_dir: directory containing all the files to sort
    :param output_dir: optional directory to put the results in; if this is None, uses the input_dir, default None.
    :param read_filter: optional ReadFilter to limit which files to sort, default empty filter (sort everything)
    :param copy: optional value that when set ensures the file contents are copied into the new structure. When this
                 is set to False, the files will instead by moved.

    :return: True if success, False if failure
    &#34;&#34;&#34;
    if output_dir is None:
        output_dir = input_dir
    check_type(input_dir, [str])
    check_type(output_dir, [str])
    check_type(read_filter, [ReadFilter])

    if not os.path.exists(input_dir):
        print(
            f&#34;Directory with files to sort: {input_dir} does not exist.  Stopping program.&#34;
        )
        return False

    if not os.path.exists(output_dir):
        print(
            f&#34;Base directory for creation: {output_dir} does not exist.  Please create it.  Stopping program.&#34;
        )
        return False

    index: Index = Index()
    extension: str
    for extension in read_filter.extensions:
        pattern: str = str(PurePath(input_dir).joinpath(f&#34;*{extension}&#34;))
        paths: List[str] = glob(os.path.join(input_dir, pattern))
        entries: Iterator[IndexEntry] = filter(
            read_filter.apply, filter(_not_none, map(IndexEntry.from_path, paths))
        )
        index.append(entries)

    if len(index.entries) &lt; 1:
        print(
            f&#34;Directory with files to sort: {input_dir} does not contain Redvox data to read.  Stopping program.&#34;
        )
        return False

    for value in index.entries:
        api_version = value.api_version
        if api_version == ApiVersion.API_1000:
            file_out_dir = str(
                PurePath(output_dir).joinpath(
                    &#34;api1000&#34;,
                    f&#34;{value.date_time.year:04}&#34;,
                    f&#34;{value.date_time.month:02}&#34;,
                    f&#34;{value.date_time.day:02}&#34;,
                    f&#34;{value.date_time.hour:02}&#34;,
                )
            )
        elif api_version == ApiVersion.API_900:
            file_out_dir = str(
                PurePath(output_dir).joinpath(
                    &#34;api900&#34;,
                    f&#34;{value.date_time.year:04}&#34;,
                    f&#34;{value.date_time.month:02}&#34;,
                    f&#34;{value.date_time.day:02}&#34;,
                )
            )
        else:
            print(
                f&#34;Unknown API version {api_version} found in data.  Stopping program.&#34;
            )
            return False
        os.makedirs(file_out_dir, exist_ok=True)

        if copy:
            copy2(value.full_path, file_out_dir)
        else:
            move(value.full_path, file_out_dir)

    return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.common.io.get_json_file"><code class="name flex">
<span>def <span class="ident">get_json_file</span></span>(<span>file_dir: str) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the first json file in the file_dir specified or None if there is no file</p>
<p>:param file_dir: directory to find json file in
:return: full name of first json file in the directory or None if no files found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_json_file(file_dir: str) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Finds the first json file in the file_dir specified or None if there is no file

    :param file_dir: directory to find json file in
    :return: full name of first json file in the directory or None if no files found
    &#34;&#34;&#34;
    file_names = glob(os.path.join(file_dir, &#34;*.json&#34;))
    if len(file_names) &lt; 1:
        return None
    return Path(file_names[0]).name</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_structured"><code class="name flex">
<span>def <span class="ident">index_structured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>Indexes both API 900 and API 1000 structured directory layouts.</p>
<p>:param base_dir: The base_dir may either end with api900, api1000, or be a parent directory to one or both of
API 900 and API 1000.
:param read_filter: Filter to further filter results.
:param pool: Pool for multiprocessing
:return: An Index of RedVox files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_structured(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Indexes both API 900 and API 1000 structured directory layouts.

    :param base_dir: The base_dir may either end with api900, api1000, or be a parent directory to one or both of
                     API 900 and API 1000.
    :param read_filter: Filter to further filter results.
    :param pool: Pool for multiprocessing
    :return: An Index of RedVox files.
    &#34;&#34;&#34;
    return __INDEX_STRUCTURED_FN(base_dir, read_filter, pool)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_structured_api_1000"><code class="name flex">
<span>def <span class="ident">index_structured_api_1000</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), sort: bool = True, pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>This parses a structured API M directory structure and identifies files that match the provided filter.</p>
<p>:param base_dir: Base directory (should be named api1000)
:param read_filter: Filter to filter files with
:param sort: When True, the resulting Index will be sorted before being returned (default=True).
:param pool: Pool for multiprocessing
:return: A list of wrapped packets on an empty list if none match the filter or none are found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_structured_api_1000(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API M directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api1000)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    return __INDEX_STRUCTURED_1000_FN(base_dir, read_filter, sort, pool)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_structured_api_1000_py"><code class="name flex">
<span>def <span class="ident">index_structured_api_1000_py</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), sort: bool = True, pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>This parses a structured API M directory structure and identifies files that match the provided filter.</p>
<p>:param base_dir: Base directory (should be named api1000)
:param read_filter: Filter to filter files with
:param sort: When True, the resulting Index will be sorted before being returned (default=True).
:param pool: Pool for multiprocessing
:return: A list of wrapped packets on an empty list if none match the filter or none are found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_structured_api_1000_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API M directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api1000)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    index: Index = Index()

    _pool: multiprocessing.pool.Pool = multiprocessing.Pool() if pool is None else pool

    for year in _list_subdirs(base_dir, __VALID_YEARS):
        for month in _list_subdirs(os.path.join(base_dir, year), __VALID_MONTHS):
            for day in _list_subdirs(
                os.path.join(base_dir, year, month), __VALID_DATES
            ):
                for hour in _list_subdirs(
                    os.path.join(base_dir, year, month, day), __VALID_HOURS
                ):
                    # Before scanning for *.rdvxm files, let&#39;s see if the current year, month, day, hour are in the
                    # filter&#39;s range. If not, we can short circuit and skip getting the *.rdvxm files.
                    if not read_filter.apply_dt(
                        datetime(int(year), int(month), int(day), int(hour)),
                        dt_fn=truncate_dt_ymdh,
                    ):
                        continue

                    data_dir: str = os.path.join(base_dir, year, month, day, hour)
                    entries: Iterator[IndexEntry] = iter(
                        index_unstructured_py(
                            data_dir, read_filter, sort=False, pool=_pool
                        ).entries
                    )
                    index.append(entries)

    if pool is None:
        _pool.close()

    if sort:
        index.sort()
    return index</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_structured_api_900"><code class="name flex">
<span>def <span class="ident">index_structured_api_900</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), sort: bool = True, pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>This parses a structured API 900 directory structure and identifies files that match the provided filter.</p>
<p>:param base_dir: Base directory (should be named api900)
:param read_filter: Filter to filter files with
:param sort: When True, the resulting Index will be sorted before being returned (default=True).
:param pool: Pool for multiprocessing
:return: A list of wrapped packets on an empty list if none match the filter or none are found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_structured_api_900(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API 900 directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api900)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    return __INDEX_STRUCTURED_900_FN(base_dir, read_filter, sort, pool)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_structured_api_900_py"><code class="name flex">
<span>def <span class="ident">index_structured_api_900_py</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), sort: bool = True, pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>This parses a structured API 900 directory structure and identifies files that match the provided filter.</p>
<p>:param base_dir: Base directory (should be named api900)
:param read_filter: Filter to filter files with
:param sort: When True, the resulting Index will be sorted before being returned (default=True).
:param pool: Pool for multiprocessing
:return: A list of wrapped packets on an empty list if none match the filter or none are found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_structured_api_900_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    This parses a structured API 900 directory structure and identifies files that match the provided filter.

    :param base_dir: Base directory (should be named api900)
    :param read_filter: Filter to filter files with
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    index: Index = Index()

    _pool: multiprocessing.pool.Pool = multiprocessing.Pool() if pool is None else pool

    for year in _list_subdirs(base_dir, __VALID_YEARS):
        for month in _list_subdirs(os.path.join(base_dir, year), __VALID_MONTHS):
            for day in _list_subdirs(
                os.path.join(base_dir, year, month), __VALID_DATES
            ):
                # Before scanning for *.rdvxz files, let&#39;s see if the current year, month, day, are in the
                # filter&#39;s range. If not, we can short circuit and skip getting the *.rdvxz files.
                if not read_filter.apply_dt(
                    datetime(int(year), int(month), int(day)), dt_fn=truncate_dt_ymd
                ):
                    continue

                data_dir: str = os.path.join(base_dir, year, month, day)
                entries: Iterator[IndexEntry] = iter(
                    index_unstructured_py(
                        data_dir, read_filter, sort=False, pool=_pool
                    ).entries
                )
                index.append(entries)

    if pool is None:
        _pool.close()

    if sort:
        index.sort()
    return index</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_structured_py"><code class="name flex">
<span>def <span class="ident">index_structured_py</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>Indexes both API 900 and API 1000 structured directory layouts.</p>
<p>:param base_dir: The base_dir may either end with api900, api1000, or be a parent directory to one or both of
API 900 and API 1000.
:param read_filter: Filter to further filter results.
:param pool: Pool for multiprocessing
:return: An Index of RedVox files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_structured_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Indexes both API 900 and API 1000 structured directory layouts.

    :param base_dir: The base_dir may either end with api900, api1000, or be a parent directory to one or both of
                     API 900 and API 1000.
    :param read_filter: Filter to further filter results.
    :param pool: Pool for multiprocessing
    :return: An Index of RedVox files.
    &#34;&#34;&#34;
    base_path: PurePath = PurePath(base_dir)

    _pool: multiprocessing.pool.Pool = multiprocessing.Pool() if pool is None else pool

    # API 900
    if base_path.name == &#34;api900&#34;:
        return index_structured_api_900_py(base_dir, read_filter, pool=_pool)
    # API 1000
    elif base_path.name == &#34;api1000&#34;:
        return index_structured_api_1000_py(base_dir, read_filter, pool=_pool)
    # Maybe parent to one or both?
    else:
        index: Index = Index()
        subdirs: List[str] = list(_list_subdirs(base_dir, {&#34;api900&#34;, &#34;api1000&#34;}))
        if &#34;api900&#34; in subdirs:
            index.append(
                iter(
                    index_structured_api_900_py(
                        str(base_path.joinpath(&#34;api900&#34;)),
                        read_filter,
                        sort=False,
                        pool=_pool,
                    ).entries
                )
            )

        if &#34;api1000&#34; in subdirs:
            index.append(
                iter(
                    index_structured_api_1000_py(
                        str(base_path.joinpath(&#34;api1000&#34;)),
                        read_filter,
                        sort=False,
                        pool=_pool,
                    ).entries
                )
            )

        if pool is None:
            _pool.close()

        index.sort()
        return index</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_unstructured"><code class="name flex">
<span>def <span class="ident">index_unstructured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), sort: bool = True, pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of file paths that match the given filter for unstructured data.</p>
<p>:param base_dir: Directory containing unstructured data.
:param read_filter: An (optional) ReadFilter for specifying station IDs and time windows.
:param sort: When True, the resulting Index will be sorted before being returned (default=True).
:param pool: Pool for multiprocessing
:return: An iterator of valid paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_unstructured(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Returns the list of file paths that match the given filter for unstructured data.

    :param base_dir: Directory containing unstructured data.
    :param read_filter: An (optional) ReadFilter for specifying station IDs and time windows.
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: An iterator of valid paths.
    &#34;&#34;&#34;
    return __INDEX_UNSTRUCTURED_FN(base_dir, read_filter, sort, pool)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.index_unstructured_py"><code class="name flex">
<span>def <span class="ident">index_unstructured_py</span></span>(<span>base_dir: str, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), sort: bool = True, pool: Optional[multiprocessing.pool.Pool] = None) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of file paths that match the given filter for unstructured data.</p>
<p>:param base_dir: Directory containing unstructured data.
:param read_filter: An (optional) ReadFilter for specifying station IDs and time windows.
:param sort: When True, the resulting Index will be sorted before being returned (default=True).
:param pool: Pool for multiprocessing
:return: An iterator of valid paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_unstructured_py(
    base_dir: str,
    read_filter: ReadFilter = ReadFilter(),
    sort: bool = True,
    pool: Optional[multiprocessing.pool.Pool] = None,
) -&gt; Index:
    &#34;&#34;&#34;
    Returns the list of file paths that match the given filter for unstructured data.

    :param base_dir: Directory containing unstructured data.
    :param read_filter: An (optional) ReadFilter for specifying station IDs and time windows.
    :param sort: When True, the resulting Index will be sorted before being returned (default=True).
    :param pool: Pool for multiprocessing
    :return: An iterator of valid paths.
    &#34;&#34;&#34;
    check_type(base_dir, [str])
    check_type(read_filter, [ReadFilter])

    index: Index = Index()

    extensions: Set[str] = (
        read_filter.extensions if read_filter.extensions is not None else {&#34;&#34;}
    )

    all_paths: List[str] = []

    extension: str
    for extension in extensions:
        pattern: str = str(PurePath(base_dir).joinpath(f&#34;*{extension}&#34;))
        paths: List[str] = glob(os.path.join(base_dir, pattern))
        all_paths.extend(paths)

    all_entries: Iterator[Optional[IndexEntry]] = maybe_parallel_map(
        pool,
        IndexEntry.from_path,
        iter(all_paths),
        lambda: len(all_paths) &gt; 128,
        chunk_size=64,
    )

    # if len(all_paths) &gt; 128:
    #     _pool: multiprocessing.pool.Pool = (
    #         multiprocessing.Pool() if pool is None else pool
    #     )
    #     all_entries = _pool.imap(IndexEntry.from_path, iter(all_paths))
    #     if pool is None:
    #         _pool.close()
    # else:
    #     all_entries = map(IndexEntry.from_path, all_paths)

    entries: Iterator[IndexEntry] = filter(
        read_filter.apply, filter(_not_none, all_entries)
    )

    index.append(entries)

    if sort:
        index.sort()

    return index</code></pre>
</details>
</dd>
<dt id="redvox.common.io.json_file_to_dict"><code class="name flex">
<span>def <span class="ident">json_file_to_dict</span></span>(<span>file_path: str) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>:param file_path: full path of file to load data from.
:return: json file as python dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_file_to_dict(file_path: str) -&gt; Dict:
    &#34;&#34;&#34;
    :param file_path: full path of file to load data from.
    :return: json file as python dictionary
    &#34;&#34;&#34;
    with open(file_path, &#34;r&#34;) as f_p:
        return json_to_dict(f_p.read())</code></pre>
</details>
</dd>
<dt id="redvox.common.io.json_to_dict"><code class="name flex">
<span>def <span class="ident">json_to_dict</span></span>(<span>json_str: str) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>:param json_str: string of json to convert to dictionary
:return: json string as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_to_dict(json_str: str) -&gt; Dict:
    &#34;&#34;&#34;
    :param json_str: string of json to convert to dictionary
    :return: json string as a dictionary
    &#34;&#34;&#34;
    return json.loads(json_str)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.sort_unstructured_redvox_data"><code class="name flex">
<span>def <span class="ident">sort_unstructured_redvox_data</span></span>(<span>input_dir: str, output_dir: Optional[str] = None, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;}), copy: bool = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>takes all redvox files in input_dir and sorts them into appropriate sub-directories</p>
<p>:param input_dir: directory containing all the files to sort
:param output_dir: optional directory to put the results in; if this is None, uses the input_dir, default None.
:param read_filter: optional ReadFilter to limit which files to sort, default empty filter (sort everything)
:param copy: optional value that when set ensures the file contents are copied into the new structure. When this
is set to False, the files will instead by moved.</p>
<p>:return: True if success, False if failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_unstructured_redvox_data(
    input_dir: str,
    output_dir: Optional[str] = None,
    read_filter: ReadFilter = ReadFilter(),
    copy: bool = True,
) -&gt; bool:
    &#34;&#34;&#34;
    takes all redvox files in input_dir and sorts them into appropriate sub-directories

    :param input_dir: directory containing all the files to sort
    :param output_dir: optional directory to put the results in; if this is None, uses the input_dir, default None.
    :param read_filter: optional ReadFilter to limit which files to sort, default empty filter (sort everything)
    :param copy: optional value that when set ensures the file contents are copied into the new structure. When this
                 is set to False, the files will instead by moved.

    :return: True if success, False if failure
    &#34;&#34;&#34;
    if output_dir is None:
        output_dir = input_dir
    check_type(input_dir, [str])
    check_type(output_dir, [str])
    check_type(read_filter, [ReadFilter])

    if not os.path.exists(input_dir):
        print(
            f&#34;Directory with files to sort: {input_dir} does not exist.  Stopping program.&#34;
        )
        return False

    if not os.path.exists(output_dir):
        print(
            f&#34;Base directory for creation: {output_dir} does not exist.  Please create it.  Stopping program.&#34;
        )
        return False

    index: Index = Index()
    extension: str
    for extension in read_filter.extensions:
        pattern: str = str(PurePath(input_dir).joinpath(f&#34;*{extension}&#34;))
        paths: List[str] = glob(os.path.join(input_dir, pattern))
        entries: Iterator[IndexEntry] = filter(
            read_filter.apply, filter(_not_none, map(IndexEntry.from_path, paths))
        )
        index.append(entries)

    if len(index.entries) &lt; 1:
        print(
            f&#34;Directory with files to sort: {input_dir} does not contain Redvox data to read.  Stopping program.&#34;
        )
        return False

    for value in index.entries:
        api_version = value.api_version
        if api_version == ApiVersion.API_1000:
            file_out_dir = str(
                PurePath(output_dir).joinpath(
                    &#34;api1000&#34;,
                    f&#34;{value.date_time.year:04}&#34;,
                    f&#34;{value.date_time.month:02}&#34;,
                    f&#34;{value.date_time.day:02}&#34;,
                    f&#34;{value.date_time.hour:02}&#34;,
                )
            )
        elif api_version == ApiVersion.API_900:
            file_out_dir = str(
                PurePath(output_dir).joinpath(
                    &#34;api900&#34;,
                    f&#34;{value.date_time.year:04}&#34;,
                    f&#34;{value.date_time.month:02}&#34;,
                    f&#34;{value.date_time.day:02}&#34;,
                )
            )
        else:
            print(
                f&#34;Unknown API version {api_version} found in data.  Stopping program.&#34;
            )
            return False
        os.makedirs(file_out_dir, exist_ok=True)

        if copy:
            copy2(value.full_path, file_out_dir)
        else:
            move(value.full_path, file_out_dir)

    return True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.io.FileSystemWriter"><code class="flex name class">
<span>class <span class="ident">FileSystemWriter</span></span>
<span>(</span><span>file_name: str, file_ext: str = 'none', base_dir: str = '.', save_enabled: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>This class holds basic information about writing and reading objects from a file system
If user does not enable saving to disk, we use a temporary directory to store large files</p>
<h2 id="properties">Properties</h2>
<p>file_name: str, the name of the file (do not include extension)
file_ext: str, the extension used by the file (do not include the .).
Default "NONE"
base_dir: str, the directory to save the file to.
Default "." (current dir)
save_to_disk: bool, if True, save data to disk.
Default False</p>
<h2 id="protected">Protected</h2>
<p>_temp_dir: TemporaryDirectory, temporary directory for large files when not saving to disk</p>
<p>initialize FileSystemWriter</p>
<p>:param file_name: name of file
:param file_ext: extension of file, default "none"
:param base_dir: directory to save file to, default "." (current dir)
:param save_enabled: if True, save to the file specified by, default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileSystemWriter:
    &#34;&#34;&#34;
    This class holds basic information about writing and reading objects from a file system
    If user does not enable saving to disk, we use a temporary directory to store large files

    Properties:
        file_name: str, the name of the file (do not include extension)
        file_ext: str, the extension used by the file (do not include the .).  Default &#34;NONE&#34;
        base_dir: str, the directory to save the file to.  Default &#34;.&#34; (current dir)
        save_to_disk: bool, if True, save data to disk.  Default False

    Protected:
        _temp_dir: TemporaryDirectory, temporary directory for large files when not saving to disk
    &#34;&#34;&#34;

    def __init__(self, file_name: str, file_ext: str = &#34;none&#34;,
                 base_dir: str = &#34;.&#34;, save_enabled: bool = False):
        &#34;&#34;&#34;
        initialize FileSystemWriter

        :param file_name: name of file
        :param file_ext: extension of file, default &#34;none&#34;
        :param base_dir: directory to save file to, default &#34;.&#34; (current dir)
        :param save_enabled: if True, save to the file specified by, default False
        &#34;&#34;&#34;
        self.file_name: str = file_name
        self.file_extension: str = file_ext.lower()
        self.save_to_disk: bool = save_enabled
        self.base_dir: str = base_dir
        self._temp_dir = tempfile.TemporaryDirectory()

    def save_dir(self) -&gt; str:
        &#34;&#34;&#34;
        :return: directory where file would be saved based on current value of self.save_to_disk
        &#34;&#34;&#34;
        return self.base_dir if self.save_to_disk else self._temp_dir.name

    def full_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name with extension
        &#34;&#34;&#34;
        return f&#34;{self.file_name}.{self.file_extension}&#34;

    def full_path(self) -&gt; str:
        &#34;&#34;&#34;
        :return: the full path to where the file would be written
        &#34;&#34;&#34;
        return os.path.join(self.save_dir(), self.full_name())

    def set_name_and_extension(self, name: str, ext: str):
        &#34;&#34;&#34;
        set the name and extension of the output file.  Do not include the . for the extension
        :param name: file name
        :param ext: file extension
        &#34;&#34;&#34;
        self.file_name = name
        self.file_extension = ext

    def json_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name with .json extension
        &#34;&#34;&#34;
        return f&#34;{self.file_name}.json&#34;

    def json_path(self) -&gt; Path:
        &#34;&#34;&#34;
        :return: full path to json file
        &#34;&#34;&#34;
        return Path(self.save_dir()).joinpath(self.json_file_name())

    def create_dir(self):
        &#34;&#34;&#34;
        if saving to disk, otherwise remove any files in the directory,
        then create the directory if it doesn&#39;t exist
        &#34;&#34;&#34;
        if self.save_to_disk:
            if os.path.exists(self.save_dir()):
                rmtree(self.save_dir())
            os.makedirs(self.save_dir(), exist_ok=True)

    def __del__(self):
        &#34;&#34;&#34;
        remove temp dir
        &#34;&#34;&#34;
        self._temp_dir.cleanup()

    def as_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: FileSystemWriter as dictionary
        &#34;&#34;&#34;
        return {
            &#34;file_name&#34;: self.file_name,
            &#34;file_extension&#34;: self.file_extension,
            &#34;base_dir&#34;: self.base_dir,
            &#34;save_to_disk&#34;: self.save_to_disk
        }</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="redvox.common.data_window_io.DataWindowFileSystemWriter" href="data_window_io.html#redvox.common.data_window_io.DataWindowFileSystemWriter">DataWindowFileSystemWriter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.io.FileSystemWriter.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: FileSystemWriter as dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: FileSystemWriter as dictionary
    &#34;&#34;&#34;
    return {
        &#34;file_name&#34;: self.file_name,
        &#34;file_extension&#34;: self.file_extension,
        &#34;base_dir&#34;: self.base_dir,
        &#34;save_to_disk&#34;: self.save_to_disk
    }</code></pre>
</details>
</dd>
<dt id="redvox.common.io.FileSystemWriter.create_dir"><code class="name flex">
<span>def <span class="ident">create_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>if saving to disk, otherwise remove any files in the directory,
then create the directory if it doesn't exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_dir(self):
    &#34;&#34;&#34;
    if saving to disk, otherwise remove any files in the directory,
    then create the directory if it doesn&#39;t exist
    &#34;&#34;&#34;
    if self.save_to_disk:
        if os.path.exists(self.save_dir()):
            rmtree(self.save_dir())
        os.makedirs(self.save_dir(), exist_ok=True)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.FileSystemWriter.full_name"><code class="name flex">
<span>def <span class="ident">full_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: file name with extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_name(self) -&gt; str:
    &#34;&#34;&#34;
    :return: file name with extension
    &#34;&#34;&#34;
    return f&#34;{self.file_name}.{self.file_extension}&#34;</code></pre>
</details>
</dd>
<dt id="redvox.common.io.FileSystemWriter.full_path"><code class="name flex">
<span>def <span class="ident">full_path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the full path to where the file would be written</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_path(self) -&gt; str:
    &#34;&#34;&#34;
    :return: the full path to where the file would be written
    &#34;&#34;&#34;
    return os.path.join(self.save_dir(), self.full_name())</code></pre>
</details>
</dd>
<dt id="redvox.common.io.FileSystemWriter.json_file_name"><code class="name flex">
<span>def <span class="ident">json_file_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: file name with .json extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_file_name(self) -&gt; str:
    &#34;&#34;&#34;
    :return: file name with .json extension
    &#34;&#34;&#34;
    return f&#34;{self.file_name}.json&#34;</code></pre>
</details>
</dd>
<dt id="redvox.common.io.FileSystemWriter.json_path"><code class="name flex">
<span>def <span class="ident">json_path</span></span>(<span>self) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>:return: full path to json file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_path(self) -&gt; Path:
    &#34;&#34;&#34;
    :return: full path to json file
    &#34;&#34;&#34;
    return Path(self.save_dir()).joinpath(self.json_file_name())</code></pre>
</details>
</dd>
<dt id="redvox.common.io.FileSystemWriter.save_dir"><code class="name flex">
<span>def <span class="ident">save_dir</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: directory where file would be saved based on current value of self.save_to_disk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_dir(self) -&gt; str:
    &#34;&#34;&#34;
    :return: directory where file would be saved based on current value of self.save_to_disk
    &#34;&#34;&#34;
    return self.base_dir if self.save_to_disk else self._temp_dir.name</code></pre>
</details>
</dd>
<dt id="redvox.common.io.FileSystemWriter.set_name_and_extension"><code class="name flex">
<span>def <span class="ident">set_name_and_extension</span></span>(<span>self, name: str, ext: str)</span>
</code></dt>
<dd>
<div class="desc"><p>set the name and extension of the output file.
Do not include the . for the extension
:param name: file name
:param ext: file extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name_and_extension(self, name: str, ext: str):
    &#34;&#34;&#34;
    set the name and extension of the output file.  Do not include the . for the extension
    :param name: file name
    :param ext: file extension
    &#34;&#34;&#34;
    self.file_name = name
    self.file_extension = ext</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.io.Index"><code class="flex name class">
<span>class <span class="ident">Index</span></span>
<span>(</span><span>entries: List[<a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a>] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>An index of available RedVox files from the file system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Index:
    &#34;&#34;&#34;
    An index of available RedVox files from the file system.
    &#34;&#34;&#34;

    entries: List[IndexEntry] = field(default_factory=lambda: [])

    @staticmethod
    def from_native(index_native) -&gt; &#34;Index&#34;:
        &#34;&#34;&#34;
        Converts a native index into a python index.

        :param index_native: A native index.
        :return: A Python index.
        &#34;&#34;&#34;
        entries: List[IndexEntry] = list(
            map(IndexEntry.from_native, index_native.entries)
        )
        return Index(entries)

    def to_native(self):
        import redvox_native

        native_index = redvox_native.Index()
        native_index.entries = list(map(IndexEntry.to_native, self.entries))
        return native_index

    def sort(self) -&gt; None:
        &#34;&#34;&#34;
        Sorts the entries stored in this index.
        &#34;&#34;&#34;
        self.entries = sorted(
            self.entries,
            key=lambda entry: (entry.api_version, entry.station_id, entry.date_time),
        )

    def append(self, entries: Iterator[IndexEntry]) -&gt; None:
        &#34;&#34;&#34;
        Appends new entries to this index.

        :param entries: Entries to append.
        &#34;&#34;&#34;
        self.entries.extend(entries)

    def summarize(self) -&gt; IndexSummary:
        &#34;&#34;&#34;
        :return: A summary of the contents of this index.
        &#34;&#34;&#34;
        return IndexSummary.from_index(self)

    def get_index_for_station_id(self, station_id: str) -&gt; &#34;Index&#34;:
        &#34;&#34;&#34;
        :param station_id: id to get entries for
        :return: Index containing only the entries for the station requested
        &#34;&#34;&#34;
        return Index([en for en in self.entries if en.station_id == station_id])

    def stream_raw(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; Iterator[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, deserialize, and then stream RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be streamed.
        :return: An iterator over RedvoxPacket and RedvoxPacketM instances.
        &#34;&#34;&#34;
        filtered: Iterator[IndexEntry] = filter(read_filter.apply, self.entries)
        # noinspection Mypy
        return map(IndexEntry.read_raw, filtered)

    def stream(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; Iterator[Union[&#34;WrappedRedvoxPacket&#34;, WrappedRedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, deserialize, wrap, and then stream RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be streamed.
        :return: An iterator over WrappedRedvoxPacket and WrappedRedvoxPacketM instances.
        &#34;&#34;&#34;
        filtered: Iterator[IndexEntry] = filter(read_filter.apply, self.entries)
        # noinspection Mypy
        return map(IndexEntry.read, filtered)

    def read_raw(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; List[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, and deserialize RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be read.
        :return: An list of RedvoxPacket and RedvoxPacketM instances.
        &#34;&#34;&#34;
        return list(self.stream_raw(read_filter))

    def read(
        self, read_filter: ReadFilter = ReadFilter()
    ) -&gt; List[Union[&#34;WrappedRedvoxPacket&#34;, WrappedRedvoxPacketM]]:
        &#34;&#34;&#34;
        Read, decompress, deserialize, and wrap RedVox data pointed to by this index.

        :param read_filter: Additional filtering to specify which data should be read.
        :return: An list of WrappedRedvoxPacket and WrappedRedvoxPacketM instances.
        &#34;&#34;&#34;
        return list(self.stream(read_filter))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.io.Index.entries"><code class="name">var <span class="ident">entries</span> : List[<a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.io.Index.from_native"><code class="name flex">
<span>def <span class="ident">from_native</span></span>(<span>index_native) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts a native index into a python index.</p>
<p>:param index_native: A native index.
:return: A Python index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_native(index_native) -&gt; &#34;Index&#34;:
    &#34;&#34;&#34;
    Converts a native index into a python index.

    :param index_native: A native index.
    :return: A Python index.
    &#34;&#34;&#34;
    entries: List[IndexEntry] = list(
        map(IndexEntry.from_native, index_native.entries)
    )
    return Index(entries)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.io.Index.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, entries: Iterator[<a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Appends new entries to this index.</p>
<p>:param entries: Entries to append.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, entries: Iterator[IndexEntry]) -&gt; None:
    &#34;&#34;&#34;
    Appends new entries to this index.

    :param entries: Entries to append.
    &#34;&#34;&#34;
    self.entries.extend(entries)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.get_index_for_station_id"><code class="name flex">
<span>def <span class="ident">get_index_for_station_id</span></span>(<span>self, station_id: str) ‑> <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param station_id: id to get entries for
:return: Index containing only the entries for the station requested</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index_for_station_id(self, station_id: str) -&gt; &#34;Index&#34;:
    &#34;&#34;&#34;
    :param station_id: id to get entries for
    :return: Index containing only the entries for the station requested
    &#34;&#34;&#34;
    return Index([en for en in self.entries if en.station_id == station_id])</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;})) ‑> List[Union[WrappedRedvoxPacket, <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read, decompress, deserialize, and wrap RedVox data pointed to by this index.</p>
<p>:param read_filter: Additional filtering to specify which data should be read.
:return: An list of WrappedRedvoxPacket and WrappedRedvoxPacketM instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(
    self, read_filter: ReadFilter = ReadFilter()
) -&gt; List[Union[&#34;WrappedRedvoxPacket&#34;, WrappedRedvoxPacketM]]:
    &#34;&#34;&#34;
    Read, decompress, deserialize, and wrap RedVox data pointed to by this index.

    :param read_filter: Additional filtering to specify which data should be read.
    :return: An list of WrappedRedvoxPacket and WrappedRedvoxPacketM instances.
    &#34;&#34;&#34;
    return list(self.stream(read_filter))</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.read_raw"><code class="name flex">
<span>def <span class="ident">read_raw</span></span>(<span>self, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;})) ‑> List[Union[RedvoxPacket, src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read, decompress, and deserialize RedVox data pointed to by this index.</p>
<p>:param read_filter: Additional filtering to specify which data should be read.
:return: An list of RedvoxPacket and RedvoxPacketM instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_raw(
    self, read_filter: ReadFilter = ReadFilter()
) -&gt; List[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
    &#34;&#34;&#34;
    Read, decompress, and deserialize RedVox data pointed to by this index.

    :param read_filter: Additional filtering to specify which data should be read.
    :return: An list of RedvoxPacket and RedvoxPacketM instances.
    &#34;&#34;&#34;
    return list(self.stream_raw(read_filter))</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sorts the entries stored in this index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self) -&gt; None:
    &#34;&#34;&#34;
    Sorts the entries stored in this index.
    &#34;&#34;&#34;
    self.entries = sorted(
        self.entries,
        key=lambda entry: (entry.api_version, entry.station_id, entry.date_time),
    )</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.stream"><code class="name flex">
<span>def <span class="ident">stream</span></span>(<span>self, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;})) ‑> Iterator[Union[WrappedRedvoxPacket, <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read, decompress, deserialize, wrap, and then stream RedVox data pointed to by this index.</p>
<p>:param read_filter: Additional filtering to specify which data should be streamed.
:return: An iterator over WrappedRedvoxPacket and WrappedRedvoxPacketM instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream(
    self, read_filter: ReadFilter = ReadFilter()
) -&gt; Iterator[Union[&#34;WrappedRedvoxPacket&#34;, WrappedRedvoxPacketM]]:
    &#34;&#34;&#34;
    Read, decompress, deserialize, wrap, and then stream RedVox data pointed to by this index.

    :param read_filter: Additional filtering to specify which data should be streamed.
    :return: An iterator over WrappedRedvoxPacket and WrappedRedvoxPacketM instances.
    &#34;&#34;&#34;
    filtered: Iterator[IndexEntry] = filter(read_filter.apply, self.entries)
    # noinspection Mypy
    return map(IndexEntry.read, filtered)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.stream_raw"><code class="name flex">
<span>def <span class="ident">stream_raw</span></span>(<span>self, read_filter: <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extensions={&#x27;.rdvxm&#x27;, &#x27;.rdvxz&#x27;}, start_dt_buf=datetime.timedelta(seconds=120), end_dt_buf=datetime.timedelta(seconds=120), api_versions={&lt;ApiVersion.API_1000: &#x27;API_1000&#x27;&gt;, &lt;ApiVersion.API_900: &#x27;API_900&#x27;&gt;})) ‑> Iterator[Union[RedvoxPacket, src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read, decompress, deserialize, and then stream RedVox data pointed to by this index.</p>
<p>:param read_filter: Additional filtering to specify which data should be streamed.
:return: An iterator over RedvoxPacket and RedvoxPacketM instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_raw(
    self, read_filter: ReadFilter = ReadFilter()
) -&gt; Iterator[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
    &#34;&#34;&#34;
    Read, decompress, deserialize, and then stream RedVox data pointed to by this index.

    :param read_filter: Additional filtering to specify which data should be streamed.
    :return: An iterator over RedvoxPacket and RedvoxPacketM instances.
    &#34;&#34;&#34;
    filtered: Iterator[IndexEntry] = filter(read_filter.apply, self.entries)
    # noinspection Mypy
    return map(IndexEntry.read_raw, filtered)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>self) ‑> <a title="redvox.common.io.IndexSummary" href="#redvox.common.io.IndexSummary">IndexSummary</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: A summary of the contents of this index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(self) -&gt; IndexSummary:
    &#34;&#34;&#34;
    :return: A summary of the contents of this index.
    &#34;&#34;&#34;
    return IndexSummary.from_index(self)</code></pre>
</details>
</dd>
<dt id="redvox.common.io.Index.to_native"><code class="name flex">
<span>def <span class="ident">to_native</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_native(self):
    import redvox_native

    native_index = redvox_native.Index()
    native_index.entries = list(map(IndexEntry.to_native, self.entries))
    return native_index</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.io.IndexEntry"><code class="flex name class">
<span>class <span class="ident">IndexEntry</span></span>
<span>(</span><span>full_path: str, station_id: str, date_time: datetime.datetime, extension: str, api_version: <a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a single index entry. It extracts and encapsulated API agnostic fields that represent the
information stored in standard RedVox file names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class IndexEntry:
    &#34;&#34;&#34;
    This class represents a single index entry. It extracts and encapsulated API agnostic fields that represent the
    information stored in standard RedVox file names.
    &#34;&#34;&#34;

    full_path: str
    station_id: str
    date_time: datetime
    extension: str
    api_version: ApiVersion

    @staticmethod
    def from_path(path_str: str, strict: bool = True) -&gt; Optional[&#34;IndexEntry&#34;]:
        &#34;&#34;&#34;
        Attempts to parse a file path into an IndexEntry. If a given path is not recognized as a valid RedVox file,
        None will be returned instead.

        :param path_str: The file system path to attempt to parse.
        :param strict: When set, None is returned if the referenced file DNE.
        :return: Either an IndexEntry or successful parse or None.
        &#34;&#34;&#34;
        api_version: ApiVersion = check_version(path_str)
        path: Path = Path(path_str)
        name: str = path.stem
        ext: str = path.suffix

        # Attempt to parse file name parts
        split_name = name.split(&#34;_&#34;)
        if len(split_name) != 2:
            return None

        station_id: str = split_name[0]
        ts_str: str = split_name[1]

        # If you have a filename with a dot, but not an extension, i.e. &#34;0000000001_0.&#34;, we need to remove the dot
        # from the end and make in the extension
        if len(ts_str) &gt; 0 and ts_str[-1] == &#34;.&#34;:
            ts_str = ts_str[:-1]
            ext = &#34;.&#34;

        timestamp: Optional[int] = _is_int(ts_str)

        # Ensure that both the station ID and timestamp can be represented as ints
        if _is_int(station_id) is None or timestamp is None:
            return None

        # Parse the datetime per the specified API version
        date_time: datetime
        if api_version == ApiVersion.API_1000:
            date_time = dt_us(timestamp)
        else:
            date_time = dt_ms(timestamp)

        full_path: str
        try:
            full_path = str(path.resolve(strict=True))
        except FileNotFoundError:
            if strict:
                return None
            full_path = path_str

        return IndexEntry(full_path, station_id, date_time, ext, api_version)

    @staticmethod
    def from_native(entry) -&gt; &#34;IndexEntry&#34;:
        &#34;&#34;&#34;
        Converts a native index entry into a python index entry.

        :param entry: A native index entry.
        :return: A python index entry.
        &#34;&#34;&#34;
        return IndexEntry(
            entry.full_path,
            entry.station_id,
            dt_us(entry.date_time),
            entry.extension,
            ApiVersion.from_str(entry.api_version),
        )

    def to_native(self):
        import redvox_native

        entry = redvox_native.IndexEntry(
            self.full_path,
            self.station_id,
            us_dt(self.date_time),
            self.extension,
            self.api_version.value,
        )
        return entry

    def read(self) -&gt; Optional[Union[WrappedRedvoxPacketM, &#34;WrappedRedvoxPacket&#34;]]:
        &#34;&#34;&#34;
        Reads, decompresses, deserializes, and wraps the RedVox file pointed to by this entry.

        :return: One of WrappedRedvoxPacket, WrappedRedvoxPacketM, or None.
        &#34;&#34;&#34;
        if self.api_version == ApiVersion.API_900:
            return read_rdvxz_file(self.full_path)
        elif self.api_version == ApiVersion.API_1000:
            return WrappedRedvoxPacketM.from_compressed_path(self.full_path)
        else:
            return None

    def read_raw(self) -&gt; Optional[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
        &#34;&#34;&#34;
        Reads, decompresses, and deserializes the RedVox file pointed to by this entry.

        :return: One of RedvoxPacket, RedvoxPacketM, or None. Note that these are the raw protobuf types.
        &#34;&#34;&#34;
        if self.api_version == ApiVersion.API_900:
            with open(self.full_path, &#34;rb&#34;) as buf_in:
                return read_buffer(buf_in.read())
        elif self.api_version == ApiVersion.API_1000:
            with lz4.frame.open(self.full_path, &#34;rb&#34;) as serialized_in:
                proto: RedvoxPacketM = RedvoxPacketM()
                proto.ParseFromString(serialized_in.read())
                return proto
        else:
            return None

    def _into_native(self):
        pass

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;
        Tests if this value is equal to another value.
        This along with __lt__ are used to fulfill the total ordering contract. Compares this entry&#39;s full path to
        another entries full path.

        :param other: Other IndexEntry to compare against.
        :return: True if this full path is less than the other full path.
        &#34;&#34;&#34;
        if isinstance(other, IndexEntry):
            return self.full_path == other.full_path

        return False</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.io.IndexEntry.api_version"><code class="name">var <span class="ident">api_version</span> : <a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexEntry.date_time"><code class="name">var <span class="ident">date_time</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexEntry.extension"><code class="name">var <span class="ident">extension</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexEntry.full_path"><code class="name">var <span class="ident">full_path</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexEntry.station_id"><code class="name">var <span class="ident">station_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.io.IndexEntry.from_native"><code class="name flex">
<span>def <span class="ident">from_native</span></span>(<span>entry) ‑> <a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts a native index entry into a python index entry.</p>
<p>:param entry: A native index entry.
:return: A python index entry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_native(entry) -&gt; &#34;IndexEntry&#34;:
    &#34;&#34;&#34;
    Converts a native index entry into a python index entry.

    :param entry: A native index entry.
    :return: A python index entry.
    &#34;&#34;&#34;
    return IndexEntry(
        entry.full_path,
        entry.station_id,
        dt_us(entry.date_time),
        entry.extension,
        ApiVersion.from_str(entry.api_version),
    )</code></pre>
</details>
</dd>
<dt id="redvox.common.io.IndexEntry.from_path"><code class="name flex">
<span>def <span class="ident">from_path</span></span>(<span>path_str: str, strict: bool = True) ‑> Optional[<a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to parse a file path into an IndexEntry. If a given path is not recognized as a valid RedVox file,
None will be returned instead.</p>
<p>:param path_str: The file system path to attempt to parse.
:param strict: When set, None is returned if the referenced file DNE.
:return: Either an IndexEntry or successful parse or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_path(path_str: str, strict: bool = True) -&gt; Optional[&#34;IndexEntry&#34;]:
    &#34;&#34;&#34;
    Attempts to parse a file path into an IndexEntry. If a given path is not recognized as a valid RedVox file,
    None will be returned instead.

    :param path_str: The file system path to attempt to parse.
    :param strict: When set, None is returned if the referenced file DNE.
    :return: Either an IndexEntry or successful parse or None.
    &#34;&#34;&#34;
    api_version: ApiVersion = check_version(path_str)
    path: Path = Path(path_str)
    name: str = path.stem
    ext: str = path.suffix

    # Attempt to parse file name parts
    split_name = name.split(&#34;_&#34;)
    if len(split_name) != 2:
        return None

    station_id: str = split_name[0]
    ts_str: str = split_name[1]

    # If you have a filename with a dot, but not an extension, i.e. &#34;0000000001_0.&#34;, we need to remove the dot
    # from the end and make in the extension
    if len(ts_str) &gt; 0 and ts_str[-1] == &#34;.&#34;:
        ts_str = ts_str[:-1]
        ext = &#34;.&#34;

    timestamp: Optional[int] = _is_int(ts_str)

    # Ensure that both the station ID and timestamp can be represented as ints
    if _is_int(station_id) is None or timestamp is None:
        return None

    # Parse the datetime per the specified API version
    date_time: datetime
    if api_version == ApiVersion.API_1000:
        date_time = dt_us(timestamp)
    else:
        date_time = dt_ms(timestamp)

    full_path: str
    try:
        full_path = str(path.resolve(strict=True))
    except FileNotFoundError:
        if strict:
            return None
        full_path = path_str

    return IndexEntry(full_path, station_id, date_time, ext, api_version)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.io.IndexEntry.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self) ‑> Union[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>, WrappedRedvoxPacket, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads, decompresses, deserializes, and wraps the RedVox file pointed to by this entry.</p>
<p>:return: One of WrappedRedvoxPacket, WrappedRedvoxPacketM, or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; Optional[Union[WrappedRedvoxPacketM, &#34;WrappedRedvoxPacket&#34;]]:
    &#34;&#34;&#34;
    Reads, decompresses, deserializes, and wraps the RedVox file pointed to by this entry.

    :return: One of WrappedRedvoxPacket, WrappedRedvoxPacketM, or None.
    &#34;&#34;&#34;
    if self.api_version == ApiVersion.API_900:
        return read_rdvxz_file(self.full_path)
    elif self.api_version == ApiVersion.API_1000:
        return WrappedRedvoxPacketM.from_compressed_path(self.full_path)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="redvox.common.io.IndexEntry.read_raw"><code class="name flex">
<span>def <span class="ident">read_raw</span></span>(<span>self) ‑> Union[RedvoxPacket, src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads, decompresses, and deserializes the RedVox file pointed to by this entry.</p>
<p>:return: One of RedvoxPacket, RedvoxPacketM, or None. Note that these are the raw protobuf types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_raw(self) -&gt; Optional[Union[&#34;RedvoxPacket&#34;, RedvoxPacketM]]:
    &#34;&#34;&#34;
    Reads, decompresses, and deserializes the RedVox file pointed to by this entry.

    :return: One of RedvoxPacket, RedvoxPacketM, or None. Note that these are the raw protobuf types.
    &#34;&#34;&#34;
    if self.api_version == ApiVersion.API_900:
        with open(self.full_path, &#34;rb&#34;) as buf_in:
            return read_buffer(buf_in.read())
    elif self.api_version == ApiVersion.API_1000:
        with lz4.frame.open(self.full_path, &#34;rb&#34;) as serialized_in:
            proto: RedvoxPacketM = RedvoxPacketM()
            proto.ParseFromString(serialized_in.read())
            return proto
    else:
        return None</code></pre>
</details>
</dd>
<dt id="redvox.common.io.IndexEntry.to_native"><code class="name flex">
<span>def <span class="ident">to_native</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_native(self):
    import redvox_native

    entry = redvox_native.IndexEntry(
        self.full_path,
        self.station_id,
        us_dt(self.date_time),
        self.extension,
        self.api_version.value,
    )
    return entry</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.io.IndexStationSummary"><code class="flex name class">
<span>class <span class="ident">IndexStationSummary</span></span>
<span>(</span><span>station_id: str, api_version: <a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a>, total_packets: int, first_packet: datetime.datetime, last_packet: datetime.datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary of a single station in the index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class IndexStationSummary:
    &#34;&#34;&#34;
    Summary of a single station in the index.
    &#34;&#34;&#34;

    station_id: str
    api_version: ApiVersion
    total_packets: int
    first_packet: datetime
    last_packet: datetime

    @staticmethod
    def from_entry(entry: IndexEntry) -&gt; &#34;IndexStationSummary&#34;:
        &#34;&#34;&#34;
        Instantiates a new summary from a given IndexEntry.

        :param entry: Entry to copy information from.
        :return: An instance of IndexStationSummary.
        &#34;&#34;&#34;
        return IndexStationSummary(
            entry.station_id,
            entry.api_version,
            1,
            first_packet=entry.date_time,
            last_packet=entry.date_time,
        )

    def update(self, entry: IndexEntry) -&gt; None:
        &#34;&#34;&#34;
        Updates this summary given a new index entry.

        :param entry: Entry to update this summary from.
        &#34;&#34;&#34;
        self.total_packets += 1
        if entry.date_time &lt; self.first_packet:
            self.first_packet = entry.date_time

        if entry.date_time &gt; self.last_packet:
            self.last_packet = entry.date_time</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.io.IndexStationSummary.api_version"><code class="name">var <span class="ident">api_version</span> : <a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexStationSummary.first_packet"><code class="name">var <span class="ident">first_packet</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexStationSummary.last_packet"><code class="name">var <span class="ident">last_packet</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexStationSummary.station_id"><code class="name">var <span class="ident">station_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.IndexStationSummary.total_packets"><code class="name">var <span class="ident">total_packets</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.io.IndexStationSummary.from_entry"><code class="name flex">
<span>def <span class="ident">from_entry</span></span>(<span>entry: <a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a>) ‑> <a title="redvox.common.io.IndexStationSummary" href="#redvox.common.io.IndexStationSummary">IndexStationSummary</a></span>
</code></dt>
<dd>
<div class="desc"><p>Instantiates a new summary from a given IndexEntry.</p>
<p>:param entry: Entry to copy information from.
:return: An instance of IndexStationSummary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_entry(entry: IndexEntry) -&gt; &#34;IndexStationSummary&#34;:
    &#34;&#34;&#34;
    Instantiates a new summary from a given IndexEntry.

    :param entry: Entry to copy information from.
    :return: An instance of IndexStationSummary.
    &#34;&#34;&#34;
    return IndexStationSummary(
        entry.station_id,
        entry.api_version,
        1,
        first_packet=entry.date_time,
        last_packet=entry.date_time,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.io.IndexStationSummary.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, entry: <a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates this summary given a new index entry.</p>
<p>:param entry: Entry to update this summary from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, entry: IndexEntry) -&gt; None:
    &#34;&#34;&#34;
    Updates this summary given a new index entry.

    :param entry: Entry to update this summary from.
    &#34;&#34;&#34;
    self.total_packets += 1
    if entry.date_time &lt; self.first_packet:
        self.first_packet = entry.date_time

    if entry.date_time &gt; self.last_packet:
        self.last_packet = entry.date_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.io.IndexSummary"><code class="flex name class">
<span>class <span class="ident">IndexSummary</span></span>
<span>(</span><span>station_summaries: Dict[<a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a>, Dict[str, <a title="redvox.common.io.IndexStationSummary" href="#redvox.common.io.IndexStationSummary">IndexStationSummary</a>]])</span>
</code></dt>
<dd>
<div class="desc"><p>Summarizes the contents of the index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class IndexSummary:
    &#34;&#34;&#34;
    Summarizes the contents of the index.
    &#34;&#34;&#34;

    station_summaries: Dict[ApiVersion, Dict[str, IndexStationSummary]]

    def station_ids(self, api_version: ApiVersion = None) -&gt; List[str]:
        &#34;&#34;&#34;
        Returns the station IDs referenced by this index.

        :param api_version: An (optional) filter to only return packets for a specified RedVox API version.
                            None will collect station IDs from all API versions.
        :return: The station IDs referenced by this index.
        &#34;&#34;&#34;
        if api_version is not None:
            return list(
                set(
                    map(
                        lambda summary: summary.station_id,
                        self.station_summaries[api_version].values(),
                    )
                )
            )
        else:
            # noinspection PyTypeChecker
            return list(
                set(
                    map(
                        lambda summary: summary.station_id,
                        self.station_summaries[ApiVersion.API_900].values(),
                    )
                )
            ) + list(
                set(
                    map(
                        lambda summary: summary.station_id,
                        self.station_summaries[ApiVersion.API_1000].values(),
                    )
                )
            )

    def total_packets(self, api_version: ApiVersion = None) -&gt; int:
        &#34;&#34;&#34;
        Returns the total number of packets referenced by this index.

        :param api_version: An (optional) filter to only return packets for a specified RedVox API version.
                            None will count packets from all API versions.
        :return: The total number of packets referenced by this index.
        &#34;&#34;&#34;
        if api_version is not None:
            return sum(
                map(
                    lambda summary: summary.total_packets,
                    self.station_summaries[api_version].values(),
                )
            )
        else:
            # noinspection PyTypeChecker
            return sum(
                map(
                    lambda summary: summary.total_packets,
                    self.station_summaries[ApiVersion.API_900].values(),
                )
            ) + sum(
                map(
                    lambda summary: summary.total_packets,
                    self.station_summaries[ApiVersion.API_1000].values(),
                )
            )

    @staticmethod
    def from_index(index: &#34;Index&#34;) -&gt; &#34;IndexSummary&#34;:
        &#34;&#34;&#34;
        Builds an IndexSummary from a given index.

        :param index: Index to build summary from.
        :return: An instance of IndexSummary.
        &#34;&#34;&#34;
        station_summaries: Dict[
            ApiVersion, Dict[str, IndexStationSummary]
        ] = defaultdict(dict)

        entry: IndexEntry
        for entry in index.entries:
            sub_entry: Dict[str, IndexStationSummary] = station_summaries[
                entry.api_version
            ]
            if entry.station_id in sub_entry:
                # Update existing station summary
                sub_entry[entry.station_id].update(entry)
            else:
                # Create new station summary
                sub_entry[entry.station_id] = IndexStationSummary.from_entry(entry)

        return IndexSummary(station_summaries)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.io.IndexSummary.station_summaries"><code class="name">var <span class="ident">station_summaries</span> : Dict[<a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a>, Dict[str, <a title="redvox.common.io.IndexStationSummary" href="#redvox.common.io.IndexStationSummary">IndexStationSummary</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.io.IndexSummary.from_index"><code class="name flex">
<span>def <span class="ident">from_index</span></span>(<span>index: <a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a>) ‑> <a title="redvox.common.io.IndexSummary" href="#redvox.common.io.IndexSummary">IndexSummary</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds an IndexSummary from a given index.</p>
<p>:param index: Index to build summary from.
:return: An instance of IndexSummary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_index(index: &#34;Index&#34;) -&gt; &#34;IndexSummary&#34;:
    &#34;&#34;&#34;
    Builds an IndexSummary from a given index.

    :param index: Index to build summary from.
    :return: An instance of IndexSummary.
    &#34;&#34;&#34;
    station_summaries: Dict[
        ApiVersion, Dict[str, IndexStationSummary]
    ] = defaultdict(dict)

    entry: IndexEntry
    for entry in index.entries:
        sub_entry: Dict[str, IndexStationSummary] = station_summaries[
            entry.api_version
        ]
        if entry.station_id in sub_entry:
            # Update existing station summary
            sub_entry[entry.station_id].update(entry)
        else:
            # Create new station summary
            sub_entry[entry.station_id] = IndexStationSummary.from_entry(entry)

    return IndexSummary(station_summaries)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.io.IndexSummary.station_ids"><code class="name flex">
<span>def <span class="ident">station_ids</span></span>(<span>self, api_version: <a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a> = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the station IDs referenced by this index.</p>
<p>:param api_version: An (optional) filter to only return packets for a specified RedVox API version.
None will collect station IDs from all API versions.
:return: The station IDs referenced by this index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def station_ids(self, api_version: ApiVersion = None) -&gt; List[str]:
    &#34;&#34;&#34;
    Returns the station IDs referenced by this index.

    :param api_version: An (optional) filter to only return packets for a specified RedVox API version.
                        None will collect station IDs from all API versions.
    :return: The station IDs referenced by this index.
    &#34;&#34;&#34;
    if api_version is not None:
        return list(
            set(
                map(
                    lambda summary: summary.station_id,
                    self.station_summaries[api_version].values(),
                )
            )
        )
    else:
        # noinspection PyTypeChecker
        return list(
            set(
                map(
                    lambda summary: summary.station_id,
                    self.station_summaries[ApiVersion.API_900].values(),
                )
            )
        ) + list(
            set(
                map(
                    lambda summary: summary.station_id,
                    self.station_summaries[ApiVersion.API_1000].values(),
                )
            )
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.io.IndexSummary.total_packets"><code class="name flex">
<span>def <span class="ident">total_packets</span></span>(<span>self, api_version: <a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a> = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the total number of packets referenced by this index.</p>
<p>:param api_version: An (optional) filter to only return packets for a specified RedVox API version.
None will count packets from all API versions.
:return: The total number of packets referenced by this index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_packets(self, api_version: ApiVersion = None) -&gt; int:
    &#34;&#34;&#34;
    Returns the total number of packets referenced by this index.

    :param api_version: An (optional) filter to only return packets for a specified RedVox API version.
                        None will count packets from all API versions.
    :return: The total number of packets referenced by this index.
    &#34;&#34;&#34;
    if api_version is not None:
        return sum(
            map(
                lambda summary: summary.total_packets,
                self.station_summaries[api_version].values(),
            )
        )
    else:
        # noinspection PyTypeChecker
        return sum(
            map(
                lambda summary: summary.total_packets,
                self.station_summaries[ApiVersion.API_900].values(),
            )
        ) + sum(
            map(
                lambda summary: summary.total_packets,
                self.station_summaries[ApiVersion.API_1000].values(),
            )
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.io.ReadFilter"><code class="flex name class">
<span>class <span class="ident">ReadFilter</span></span>
<span>(</span><span>start_dt: Optional[datetime.datetime] = None, end_dt: Optional[datetime.datetime] = None, station_ids: Optional[Set[str]] = None, extensions: Optional[Set[str]] = &lt;factory&gt;, start_dt_buf: Optional[datetime.timedelta] = datetime.timedelta(seconds=120), end_dt_buf: Optional[datetime.timedelta] = datetime.timedelta(seconds=120), api_versions: Optional[Set[<a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a>]] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter RedVox files from the file system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ReadFilter:
    &#34;&#34;&#34;
    Filter RedVox files from the file system.
    &#34;&#34;&#34;

    start_dt: Optional[datetime] = None
    end_dt: Optional[datetime] = None
    station_ids: Optional[Set[str]] = None
    extensions: Optional[Set[str]] = field(default_factory=lambda: {&#34;.rdvxm&#34;, &#34;.rdvxz&#34;})
    start_dt_buf: Optional[timedelta] = timedelta(minutes=2.0)
    end_dt_buf: Optional[timedelta] = timedelta(minutes=2.0)
    api_versions: Optional[Set[ApiVersion]] = field(
        default_factory=lambda: {ApiVersion.API_900, ApiVersion.API_1000}
    )

    @staticmethod
    def empty() -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        :return: A ReadFilter with ALL filters set to None. This is opposed to the default
                 which sets sane defaults for extensions, APIs, and window buffers.
        &#34;&#34;&#34;
        return ReadFilter(None, None, None, None, None, None, None)

    def clone(self) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        :return: a copy of the calling ReadFilter
        &#34;&#34;&#34;
        return_filter = ReadFilter()
        return (
            return_filter.with_start_dt(self.start_dt)
            .with_end_dt(self.end_dt)
            .with_station_ids(self.station_ids)
            .with_extensions(self.extensions)
            .with_start_dt_buf(self.start_dt_buf)
            .with_end_dt_buf(self.end_dt_buf)
            .with_api_versions(self.api_versions)
        )

    def with_start_dt(self, start_dt: Optional[datetime]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Adds a start datetime filter.

        :param start_dt: Start datetime that files should come after.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(start_dt, [datetime, None])
        self.start_dt = start_dt
        return self

    def with_start_ts(self, start_ts: Optional[float]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Adds a start time filter.

        :param start_ts: Start timestamp (microseconds)
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(start_ts, [int, float, None])
        if start_ts is None:
            return self.with_start_dt(None)

        return self.with_start_dt(dt_us(start_ts))

    def with_end_dt(self, end_dt: Optional[datetime]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Adds an end datetime filter.

        :param end_dt: Filter for which packets should come before.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(end_dt, [datetime, None])
        self.end_dt = end_dt
        return self

    def with_end_ts(self, end_ts: Optional[float]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Like with_end_dt, but uses a microsecond timestamp.

        :param end_ts: Timestamp microseconds.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(end_ts, [int, float, None])
        if end_ts is None:
            return self.with_end_dt(None)

        return self.with_end_dt(dt_us(end_ts))

    def with_station_ids(self, station_ids: Optional[Set[str]]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Add a station id filter. Filters against provided station ids.

        :param station_ids: Station ids to filter against.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(station_ids, [set, None])
        self.station_ids = station_ids
        return self

    def with_extensions(self, extensions: Optional[Set[str]]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Filters against known file extensions.

        :param extensions: One or more extensions to filter against
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        check_type(extensions, [set, None])
        self.extensions = extensions
        return self

    def with_start_dt_buf(self, start_dt_buf: Optional[timedelta]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Modifies the time buffer prepended to the start time.

        :param start_dt_buf: Amount of time to buffer before start time.
        :return: A modified instance of self.
        &#34;&#34;&#34;
        check_type(start_dt_buf, [timedelta, None])
        self.start_dt_buf = start_dt_buf
        return self

    def with_end_dt_buf(self, end_dt_buf: Optional[timedelta]) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Modifies the time buffer appended to the end time.

        :param end_dt_buf: Amount of time to buffer after end time.
        :return: A modified instance of self.
        &#34;&#34;&#34;
        check_type(end_dt_buf, [timedelta, None])
        self.end_dt_buf = end_dt_buf
        return self

    def with_api_versions(
        self, api_versions: Optional[Set[ApiVersion]]
    ) -&gt; &#34;ReadFilter&#34;:
        &#34;&#34;&#34;
        Filters for specified API versions.

        :param api_versions: A set containing valid ApiVersion enums that should be included.
        :return: A modified instance of self.
        &#34;&#34;&#34;
        check_type(api_versions, [set, None])
        self.api_versions = api_versions
        return self

    def apply_dt(
        self, date_time: datetime, dt_fn: Callable[[datetime], datetime] = lambda dt: dt
    ) -&gt; bool:
        &#34;&#34;&#34;
        Tests if a given datetime passes this filter.

        :param date_time: Datetime to test
        :param dt_fn: An (optional) function that will transform one datetime into another.
        :return: True if the datetime is included, False otherwise
        &#34;&#34;&#34;
        check_type(date_time, [datetime])
        start_buf: timedelta = (
            timedelta(seconds=0) if self.start_dt_buf is None else self.start_dt_buf
        )
        if self.start_dt is not None and date_time &lt; (dt_fn(self.start_dt - start_buf)):
            return False

        end_buf: timedelta = (
            timedelta(seconds=0) if self.end_dt_buf is None else self.end_dt_buf
        )
        if self.end_dt is not None and date_time &gt; (dt_fn(self.end_dt + end_buf)):
            return False

        return True

    def apply(self, entry: IndexEntry) -&gt; bool:
        &#34;&#34;&#34;
        Applies this filter to the given IndexEntry.

        :param entry: The entry to test.
        :return: True if the entry is accepted by the filter, False otherwise.
        &#34;&#34;&#34;
        check_type(entry, [IndexEntry])

        if not self.apply_dt(entry.date_time):
            return False

        if self.station_ids is not None and entry.station_id not in self.station_ids:
            return False

        if self.extensions is not None and entry.extension not in self.extensions:
            return False

        if self.api_versions is not None and entry.api_version not in self.api_versions:
            return False

        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.io.ReadFilter.api_versions"><code class="name">var <span class="ident">api_versions</span> : Optional[Set[<a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.ReadFilter.end_dt"><code class="name">var <span class="ident">end_dt</span> : Optional[datetime.datetime]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.ReadFilter.end_dt_buf"><code class="name">var <span class="ident">end_dt_buf</span> : Optional[datetime.timedelta]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.ReadFilter.extensions"><code class="name">var <span class="ident">extensions</span> : Optional[Set[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.ReadFilter.start_dt"><code class="name">var <span class="ident">start_dt</span> : Optional[datetime.datetime]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.ReadFilter.start_dt_buf"><code class="name">var <span class="ident">start_dt_buf</span> : Optional[datetime.timedelta]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.ReadFilter.station_ids"><code class="name">var <span class="ident">station_ids</span> : Optional[Set[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.io.ReadFilter.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: A ReadFilter with ALL filters set to None. This is opposed to the default
which sets sane defaults for extensions, APIs, and window buffers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty() -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    :return: A ReadFilter with ALL filters set to None. This is opposed to the default
             which sets sane defaults for extensions, APIs, and window buffers.
    &#34;&#34;&#34;
    return ReadFilter(None, None, None, None, None, None, None)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.io.ReadFilter.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, entry: <a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Applies this filter to the given IndexEntry.</p>
<p>:param entry: The entry to test.
:return: True if the entry is accepted by the filter, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, entry: IndexEntry) -&gt; bool:
    &#34;&#34;&#34;
    Applies this filter to the given IndexEntry.

    :param entry: The entry to test.
    :return: True if the entry is accepted by the filter, False otherwise.
    &#34;&#34;&#34;
    check_type(entry, [IndexEntry])

    if not self.apply_dt(entry.date_time):
        return False

    if self.station_ids is not None and entry.station_id not in self.station_ids:
        return False

    if self.extensions is not None and entry.extension not in self.extensions:
        return False

    if self.api_versions is not None and entry.api_version not in self.api_versions:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.apply_dt"><code class="name flex">
<span>def <span class="ident">apply_dt</span></span>(<span>self, date_time: datetime.datetime, dt_fn: Callable[[datetime.datetime], datetime.datetime] = &lt;function ReadFilter.&lt;lambda&gt;&gt;) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if a given datetime passes this filter.</p>
<p>:param date_time: Datetime to test
:param dt_fn: An (optional) function that will transform one datetime into another.
:return: True if the datetime is included, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_dt(
    self, date_time: datetime, dt_fn: Callable[[datetime], datetime] = lambda dt: dt
) -&gt; bool:
    &#34;&#34;&#34;
    Tests if a given datetime passes this filter.

    :param date_time: Datetime to test
    :param dt_fn: An (optional) function that will transform one datetime into another.
    :return: True if the datetime is included, False otherwise
    &#34;&#34;&#34;
    check_type(date_time, [datetime])
    start_buf: timedelta = (
        timedelta(seconds=0) if self.start_dt_buf is None else self.start_dt_buf
    )
    if self.start_dt is not None and date_time &lt; (dt_fn(self.start_dt - start_buf)):
        return False

    end_buf: timedelta = (
        timedelta(seconds=0) if self.end_dt_buf is None else self.end_dt_buf
    )
    if self.end_dt is not None and date_time &gt; (dt_fn(self.end_dt + end_buf)):
        return False

    return True</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: a copy of the calling ReadFilter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    :return: a copy of the calling ReadFilter
    &#34;&#34;&#34;
    return_filter = ReadFilter()
    return (
        return_filter.with_start_dt(self.start_dt)
        .with_end_dt(self.end_dt)
        .with_station_ids(self.station_ids)
        .with_extensions(self.extensions)
        .with_start_dt_buf(self.start_dt_buf)
        .with_end_dt_buf(self.end_dt_buf)
        .with_api_versions(self.api_versions)
    )</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_api_versions"><code class="name flex">
<span>def <span class="ident">with_api_versions</span></span>(<span>self, api_versions: Optional[Set[<a title="redvox.common.versioning.ApiVersion" href="versioning.html#redvox.common.versioning.ApiVersion">ApiVersion</a>]]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters for specified API versions.</p>
<p>:param api_versions: A set containing valid ApiVersion enums that should be included.
:return: A modified instance of self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_api_versions(
    self, api_versions: Optional[Set[ApiVersion]]
) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Filters for specified API versions.

    :param api_versions: A set containing valid ApiVersion enums that should be included.
    :return: A modified instance of self.
    &#34;&#34;&#34;
    check_type(api_versions, [set, None])
    self.api_versions = api_versions
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_end_dt"><code class="name flex">
<span>def <span class="ident">with_end_dt</span></span>(<span>self, end_dt: Optional[datetime.datetime]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds an end datetime filter.</p>
<p>:param end_dt: Filter for which packets should come before.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_end_dt(self, end_dt: Optional[datetime]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Adds an end datetime filter.

    :param end_dt: Filter for which packets should come before.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    check_type(end_dt, [datetime, None])
    self.end_dt = end_dt
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_end_dt_buf"><code class="name flex">
<span>def <span class="ident">with_end_dt_buf</span></span>(<span>self, end_dt_buf: Optional[datetime.timedelta]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the time buffer appended to the end time.</p>
<p>:param end_dt_buf: Amount of time to buffer after end time.
:return: A modified instance of self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_end_dt_buf(self, end_dt_buf: Optional[timedelta]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Modifies the time buffer appended to the end time.

    :param end_dt_buf: Amount of time to buffer after end time.
    :return: A modified instance of self.
    &#34;&#34;&#34;
    check_type(end_dt_buf, [timedelta, None])
    self.end_dt_buf = end_dt_buf
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_end_ts"><code class="name flex">
<span>def <span class="ident">with_end_ts</span></span>(<span>self, end_ts: Optional[float]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Like with_end_dt, but uses a microsecond timestamp.</p>
<p>:param end_ts: Timestamp microseconds.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_end_ts(self, end_ts: Optional[float]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Like with_end_dt, but uses a microsecond timestamp.

    :param end_ts: Timestamp microseconds.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    check_type(end_ts, [int, float, None])
    if end_ts is None:
        return self.with_end_dt(None)

    return self.with_end_dt(dt_us(end_ts))</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_extensions"><code class="name flex">
<span>def <span class="ident">with_extensions</span></span>(<span>self, extensions: Optional[Set[str]]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters against known file extensions.</p>
<p>:param extensions: One or more extensions to filter against
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_extensions(self, extensions: Optional[Set[str]]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Filters against known file extensions.

    :param extensions: One or more extensions to filter against
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    check_type(extensions, [set, None])
    self.extensions = extensions
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_start_dt"><code class="name flex">
<span>def <span class="ident">with_start_dt</span></span>(<span>self, start_dt: Optional[datetime.datetime]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds a start datetime filter.</p>
<p>:param start_dt: Start datetime that files should come after.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_start_dt(self, start_dt: Optional[datetime]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Adds a start datetime filter.

    :param start_dt: Start datetime that files should come after.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    check_type(start_dt, [datetime, None])
    self.start_dt = start_dt
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_start_dt_buf"><code class="name flex">
<span>def <span class="ident">with_start_dt_buf</span></span>(<span>self, start_dt_buf: Optional[datetime.timedelta]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the time buffer prepended to the start time.</p>
<p>:param start_dt_buf: Amount of time to buffer before start time.
:return: A modified instance of self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_start_dt_buf(self, start_dt_buf: Optional[timedelta]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Modifies the time buffer prepended to the start time.

    :param start_dt_buf: Amount of time to buffer before start time.
    :return: A modified instance of self.
    &#34;&#34;&#34;
    check_type(start_dt_buf, [timedelta, None])
    self.start_dt_buf = start_dt_buf
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_start_ts"><code class="name flex">
<span>def <span class="ident">with_start_ts</span></span>(<span>self, start_ts: Optional[float]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds a start time filter.</p>
<p>:param start_ts: Start timestamp (microseconds)
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_start_ts(self, start_ts: Optional[float]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Adds a start time filter.

    :param start_ts: Start timestamp (microseconds)
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    check_type(start_ts, [int, float, None])
    if start_ts is None:
        return self.with_start_dt(None)

    return self.with_start_dt(dt_us(start_ts))</code></pre>
</details>
</dd>
<dt id="redvox.common.io.ReadFilter.with_station_ids"><code class="name flex">
<span>def <span class="ident">with_station_ids</span></span>(<span>self, station_ids: Optional[Set[str]]) ‑> <a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a station id filter. Filters against provided station ids.</p>
<p>:param station_ids: Station ids to filter against.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_station_ids(self, station_ids: Optional[Set[str]]) -&gt; &#34;ReadFilter&#34;:
    &#34;&#34;&#34;
    Add a station id filter. Filters against provided station ids.

    :param station_ids: Station ids to filter against.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    check_type(station_ids, [set, None])
    self.station_ids = station_ids
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.io.RedvoxPacketM"><code class="flex name class">
<span>class <span class="ident">RedvoxPacketM</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.pyext._message.CMessage</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.io.RedvoxPacketM.BYTE"><code class="name">var <span class="ident">BYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.CENTIMETERS"><code class="name">var <span class="ident">CENTIMETERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.DECIBEL"><code class="name">var <span class="ident">DECIBEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.DECIMAL_DEGREES"><code class="name">var <span class="ident">DECIMAL_DEGREES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.DEGREES_CELSIUS"><code class="name">var <span class="ident">DEGREES_CELSIUS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.DoubleSamplePayload"><code class="name">var <span class="ident">DoubleSamplePayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.EventStream"><code class="name">var <span class="ident">EventStream</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.KILOPASCAL"><code class="name">var <span class="ident">KILOPASCAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS"><code class="name">var <span class="ident">LSB_PLUS_MINUS_COUNTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.LUX"><code class="name">var <span class="ident">LUX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.METERS"><code class="name">var <span class="ident">METERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.METERS_PER_SECOND"><code class="name">var <span class="ident">METERS_PER_SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.METERS_PER_SECOND_SQUARED"><code class="name">var <span class="ident">METERS_PER_SECOND_SQUARED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.MICROAMPERES"><code class="name">var <span class="ident">MICROAMPERES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH"><code class="name">var <span class="ident">MICROSECONDS_SINCE_UNIX_EPOCH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.MICROTESLA"><code class="name">var <span class="ident">MICROTESLA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.MetadataEntry"><code class="name">var <span class="ident">MetadataEntry</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.NORMALIZED_COUNTS"><code class="name">var <span class="ident">NORMALIZED_COUNTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.PCM"><code class="name">var <span class="ident">PCM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.PERCENTAGE"><code class="name">var <span class="ident">PERCENTAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.RADIANS"><code class="name">var <span class="ident">RADIANS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.RADIANS_PER_SECOND"><code class="name">var <span class="ident">RADIANS_PER_SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.SamplePayload"><code class="name">var <span class="ident">SamplePayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.Sensors"><code class="name">var <span class="ident">Sensors</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.StationInformation"><code class="name">var <span class="ident">StationInformation</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.SummaryStatistics"><code class="name">var <span class="ident">SummaryStatistics</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.TimingInformation"><code class="name">var <span class="ident">TimingInformation</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.TimingPayload"><code class="name">var <span class="ident">TimingPayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.UNITLESS"><code class="name">var <span class="ident">UNITLESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.Unit"><code class="name">var <span class="ident">Unit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="redvox.common.io.RedvoxPacketM.api"><code class="name">var <span class="ident">api</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.api</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.event_streams"><code class="name">var <span class="ident">event_streams</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.event_streams</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.metadata</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.sensors"><code class="name">var <span class="ident">sensors</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.sensors</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.station_information"><code class="name">var <span class="ident">station_information</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.station_information</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.sub_api"><code class="name">var <span class="ident">sub_api</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.sub_api</p></div>
</dd>
<dt id="redvox.common.io.RedvoxPacketM.timing_information"><code class="name">var <span class="ident">timing_information</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.timing_information</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.common.io.get_json_file" href="#redvox.common.io.get_json_file">get_json_file</a></code></li>
<li><code><a title="redvox.common.io.index_structured" href="#redvox.common.io.index_structured">index_structured</a></code></li>
<li><code><a title="redvox.common.io.index_structured_api_1000" href="#redvox.common.io.index_structured_api_1000">index_structured_api_1000</a></code></li>
<li><code><a title="redvox.common.io.index_structured_api_1000_py" href="#redvox.common.io.index_structured_api_1000_py">index_structured_api_1000_py</a></code></li>
<li><code><a title="redvox.common.io.index_structured_api_900" href="#redvox.common.io.index_structured_api_900">index_structured_api_900</a></code></li>
<li><code><a title="redvox.common.io.index_structured_api_900_py" href="#redvox.common.io.index_structured_api_900_py">index_structured_api_900_py</a></code></li>
<li><code><a title="redvox.common.io.index_structured_py" href="#redvox.common.io.index_structured_py">index_structured_py</a></code></li>
<li><code><a title="redvox.common.io.index_unstructured" href="#redvox.common.io.index_unstructured">index_unstructured</a></code></li>
<li><code><a title="redvox.common.io.index_unstructured_py" href="#redvox.common.io.index_unstructured_py">index_unstructured_py</a></code></li>
<li><code><a title="redvox.common.io.json_file_to_dict" href="#redvox.common.io.json_file_to_dict">json_file_to_dict</a></code></li>
<li><code><a title="redvox.common.io.json_to_dict" href="#redvox.common.io.json_to_dict">json_to_dict</a></code></li>
<li><code><a title="redvox.common.io.sort_unstructured_redvox_data" href="#redvox.common.io.sort_unstructured_redvox_data">sort_unstructured_redvox_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.io.FileSystemWriter" href="#redvox.common.io.FileSystemWriter">FileSystemWriter</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.io.FileSystemWriter.as_dict" href="#redvox.common.io.FileSystemWriter.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.io.FileSystemWriter.create_dir" href="#redvox.common.io.FileSystemWriter.create_dir">create_dir</a></code></li>
<li><code><a title="redvox.common.io.FileSystemWriter.full_name" href="#redvox.common.io.FileSystemWriter.full_name">full_name</a></code></li>
<li><code><a title="redvox.common.io.FileSystemWriter.full_path" href="#redvox.common.io.FileSystemWriter.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.io.FileSystemWriter.json_file_name" href="#redvox.common.io.FileSystemWriter.json_file_name">json_file_name</a></code></li>
<li><code><a title="redvox.common.io.FileSystemWriter.json_path" href="#redvox.common.io.FileSystemWriter.json_path">json_path</a></code></li>
<li><code><a title="redvox.common.io.FileSystemWriter.save_dir" href="#redvox.common.io.FileSystemWriter.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.io.FileSystemWriter.set_name_and_extension" href="#redvox.common.io.FileSystemWriter.set_name_and_extension">set_name_and_extension</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.io.Index" href="#redvox.common.io.Index">Index</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.io.Index.append" href="#redvox.common.io.Index.append">append</a></code></li>
<li><code><a title="redvox.common.io.Index.entries" href="#redvox.common.io.Index.entries">entries</a></code></li>
<li><code><a title="redvox.common.io.Index.from_native" href="#redvox.common.io.Index.from_native">from_native</a></code></li>
<li><code><a title="redvox.common.io.Index.get_index_for_station_id" href="#redvox.common.io.Index.get_index_for_station_id">get_index_for_station_id</a></code></li>
<li><code><a title="redvox.common.io.Index.read" href="#redvox.common.io.Index.read">read</a></code></li>
<li><code><a title="redvox.common.io.Index.read_raw" href="#redvox.common.io.Index.read_raw">read_raw</a></code></li>
<li><code><a title="redvox.common.io.Index.sort" href="#redvox.common.io.Index.sort">sort</a></code></li>
<li><code><a title="redvox.common.io.Index.stream" href="#redvox.common.io.Index.stream">stream</a></code></li>
<li><code><a title="redvox.common.io.Index.stream_raw" href="#redvox.common.io.Index.stream_raw">stream_raw</a></code></li>
<li><code><a title="redvox.common.io.Index.summarize" href="#redvox.common.io.Index.summarize">summarize</a></code></li>
<li><code><a title="redvox.common.io.Index.to_native" href="#redvox.common.io.Index.to_native">to_native</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.io.IndexEntry" href="#redvox.common.io.IndexEntry">IndexEntry</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.io.IndexEntry.api_version" href="#redvox.common.io.IndexEntry.api_version">api_version</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.date_time" href="#redvox.common.io.IndexEntry.date_time">date_time</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.extension" href="#redvox.common.io.IndexEntry.extension">extension</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.from_native" href="#redvox.common.io.IndexEntry.from_native">from_native</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.from_path" href="#redvox.common.io.IndexEntry.from_path">from_path</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.full_path" href="#redvox.common.io.IndexEntry.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.read" href="#redvox.common.io.IndexEntry.read">read</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.read_raw" href="#redvox.common.io.IndexEntry.read_raw">read_raw</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.station_id" href="#redvox.common.io.IndexEntry.station_id">station_id</a></code></li>
<li><code><a title="redvox.common.io.IndexEntry.to_native" href="#redvox.common.io.IndexEntry.to_native">to_native</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.io.IndexStationSummary" href="#redvox.common.io.IndexStationSummary">IndexStationSummary</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.io.IndexStationSummary.api_version" href="#redvox.common.io.IndexStationSummary.api_version">api_version</a></code></li>
<li><code><a title="redvox.common.io.IndexStationSummary.first_packet" href="#redvox.common.io.IndexStationSummary.first_packet">first_packet</a></code></li>
<li><code><a title="redvox.common.io.IndexStationSummary.from_entry" href="#redvox.common.io.IndexStationSummary.from_entry">from_entry</a></code></li>
<li><code><a title="redvox.common.io.IndexStationSummary.last_packet" href="#redvox.common.io.IndexStationSummary.last_packet">last_packet</a></code></li>
<li><code><a title="redvox.common.io.IndexStationSummary.station_id" href="#redvox.common.io.IndexStationSummary.station_id">station_id</a></code></li>
<li><code><a title="redvox.common.io.IndexStationSummary.total_packets" href="#redvox.common.io.IndexStationSummary.total_packets">total_packets</a></code></li>
<li><code><a title="redvox.common.io.IndexStationSummary.update" href="#redvox.common.io.IndexStationSummary.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.io.IndexSummary" href="#redvox.common.io.IndexSummary">IndexSummary</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.io.IndexSummary.from_index" href="#redvox.common.io.IndexSummary.from_index">from_index</a></code></li>
<li><code><a title="redvox.common.io.IndexSummary.station_ids" href="#redvox.common.io.IndexSummary.station_ids">station_ids</a></code></li>
<li><code><a title="redvox.common.io.IndexSummary.station_summaries" href="#redvox.common.io.IndexSummary.station_summaries">station_summaries</a></code></li>
<li><code><a title="redvox.common.io.IndexSummary.total_packets" href="#redvox.common.io.IndexSummary.total_packets">total_packets</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.io.ReadFilter" href="#redvox.common.io.ReadFilter">ReadFilter</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.io.ReadFilter.api_versions" href="#redvox.common.io.ReadFilter.api_versions">api_versions</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.apply" href="#redvox.common.io.ReadFilter.apply">apply</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.apply_dt" href="#redvox.common.io.ReadFilter.apply_dt">apply_dt</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.clone" href="#redvox.common.io.ReadFilter.clone">clone</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.empty" href="#redvox.common.io.ReadFilter.empty">empty</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.end_dt" href="#redvox.common.io.ReadFilter.end_dt">end_dt</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.end_dt_buf" href="#redvox.common.io.ReadFilter.end_dt_buf">end_dt_buf</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.extensions" href="#redvox.common.io.ReadFilter.extensions">extensions</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.start_dt" href="#redvox.common.io.ReadFilter.start_dt">start_dt</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.start_dt_buf" href="#redvox.common.io.ReadFilter.start_dt_buf">start_dt_buf</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.station_ids" href="#redvox.common.io.ReadFilter.station_ids">station_ids</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_api_versions" href="#redvox.common.io.ReadFilter.with_api_versions">with_api_versions</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_end_dt" href="#redvox.common.io.ReadFilter.with_end_dt">with_end_dt</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_end_dt_buf" href="#redvox.common.io.ReadFilter.with_end_dt_buf">with_end_dt_buf</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_end_ts" href="#redvox.common.io.ReadFilter.with_end_ts">with_end_ts</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_extensions" href="#redvox.common.io.ReadFilter.with_extensions">with_extensions</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_start_dt" href="#redvox.common.io.ReadFilter.with_start_dt">with_start_dt</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_start_dt_buf" href="#redvox.common.io.ReadFilter.with_start_dt_buf">with_start_dt_buf</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_start_ts" href="#redvox.common.io.ReadFilter.with_start_ts">with_start_ts</a></code></li>
<li><code><a title="redvox.common.io.ReadFilter.with_station_ids" href="#redvox.common.io.ReadFilter.with_station_ids">with_station_ids</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.io.RedvoxPacketM" href="#redvox.common.io.RedvoxPacketM">RedvoxPacketM</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.io.RedvoxPacketM.BYTE" href="#redvox.common.io.RedvoxPacketM.BYTE">BYTE</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.CENTIMETERS" href="#redvox.common.io.RedvoxPacketM.CENTIMETERS">CENTIMETERS</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.DECIBEL" href="#redvox.common.io.RedvoxPacketM.DECIBEL">DECIBEL</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.DECIMAL_DEGREES" href="#redvox.common.io.RedvoxPacketM.DECIMAL_DEGREES">DECIMAL_DEGREES</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.DEGREES_CELSIUS" href="#redvox.common.io.RedvoxPacketM.DEGREES_CELSIUS">DEGREES_CELSIUS</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.DESCRIPTOR" href="#redvox.common.io.RedvoxPacketM.DESCRIPTOR">DESCRIPTOR</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.DoubleSamplePayload" href="#redvox.common.io.RedvoxPacketM.DoubleSamplePayload">DoubleSamplePayload</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.EventStream" href="#redvox.common.io.RedvoxPacketM.EventStream">EventStream</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.KILOPASCAL" href="#redvox.common.io.RedvoxPacketM.KILOPASCAL">KILOPASCAL</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS" href="#redvox.common.io.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS">LSB_PLUS_MINUS_COUNTS</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.LUX" href="#redvox.common.io.RedvoxPacketM.LUX">LUX</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.METERS" href="#redvox.common.io.RedvoxPacketM.METERS">METERS</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.METERS_PER_SECOND" href="#redvox.common.io.RedvoxPacketM.METERS_PER_SECOND">METERS_PER_SECOND</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.METERS_PER_SECOND_SQUARED" href="#redvox.common.io.RedvoxPacketM.METERS_PER_SECOND_SQUARED">METERS_PER_SECOND_SQUARED</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.MICROAMPERES" href="#redvox.common.io.RedvoxPacketM.MICROAMPERES">MICROAMPERES</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH" href="#redvox.common.io.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH">MICROSECONDS_SINCE_UNIX_EPOCH</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.MICROTESLA" href="#redvox.common.io.RedvoxPacketM.MICROTESLA">MICROTESLA</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.MetadataEntry" href="#redvox.common.io.RedvoxPacketM.MetadataEntry">MetadataEntry</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.NORMALIZED_COUNTS" href="#redvox.common.io.RedvoxPacketM.NORMALIZED_COUNTS">NORMALIZED_COUNTS</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.PCM" href="#redvox.common.io.RedvoxPacketM.PCM">PCM</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.PERCENTAGE" href="#redvox.common.io.RedvoxPacketM.PERCENTAGE">PERCENTAGE</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.RADIANS" href="#redvox.common.io.RedvoxPacketM.RADIANS">RADIANS</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.RADIANS_PER_SECOND" href="#redvox.common.io.RedvoxPacketM.RADIANS_PER_SECOND">RADIANS_PER_SECOND</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.SamplePayload" href="#redvox.common.io.RedvoxPacketM.SamplePayload">SamplePayload</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.Sensors" href="#redvox.common.io.RedvoxPacketM.Sensors">Sensors</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.StationInformation" href="#redvox.common.io.RedvoxPacketM.StationInformation">StationInformation</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.SummaryStatistics" href="#redvox.common.io.RedvoxPacketM.SummaryStatistics">SummaryStatistics</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.TimingInformation" href="#redvox.common.io.RedvoxPacketM.TimingInformation">TimingInformation</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.TimingPayload" href="#redvox.common.io.RedvoxPacketM.TimingPayload">TimingPayload</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.UNITLESS" href="#redvox.common.io.RedvoxPacketM.UNITLESS">UNITLESS</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.UNKNOWN" href="#redvox.common.io.RedvoxPacketM.UNKNOWN">UNKNOWN</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.Unit" href="#redvox.common.io.RedvoxPacketM.Unit">Unit</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.api" href="#redvox.common.io.RedvoxPacketM.api">api</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.event_streams" href="#redvox.common.io.RedvoxPacketM.event_streams">event_streams</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.metadata" href="#redvox.common.io.RedvoxPacketM.metadata">metadata</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.sensors" href="#redvox.common.io.RedvoxPacketM.sensors">sensors</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.station_information" href="#redvox.common.io.RedvoxPacketM.station_information">station_information</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.sub_api" href="#redvox.common.io.RedvoxPacketM.sub_api">sub_api</a></code></li>
<li><code><a title="redvox.common.io.RedvoxPacketM.timing_information" href="#redvox.common.io.RedvoxPacketM.timing_information">timing_information</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>