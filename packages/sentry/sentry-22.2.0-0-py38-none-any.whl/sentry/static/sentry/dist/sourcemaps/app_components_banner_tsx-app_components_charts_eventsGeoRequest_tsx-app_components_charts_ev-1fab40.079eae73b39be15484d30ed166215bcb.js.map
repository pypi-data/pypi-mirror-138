{"version":3,"file":"chunks/app_components_banner_tsx-app_components_charts_eventsGeoRequest_tsx-app_components_charts_ev-1fab40.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/discoverSavedQueries.tsx","webpack:///./app/components/banner.tsx","webpack:///./app/components/charts/eventsGeoRequest.tsx","webpack:///./app/components/charts/eventsRequest.tsx","webpack:///./app/views/dashboardsV2/types.tsx","webpack:///./app/views/eventsV2/savedQuery/utils.tsx"],"sourcesContent":["import {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport {Client} from 'sentry/api';\nimport {t} from 'sentry/locale';\nimport {NewQuery, SavedQuery} from 'sentry/types';\n\nexport function fetchSavedQueries(\n  api: Client,\n  orgId: string,\n  query: string = ''\n): Promise<SavedQuery[]> {\n  const promise: Promise<SavedQuery[]> = api.requestPromise(\n    `/organizations/${orgId}/discover/saved/`,\n    {\n      method: 'GET',\n      query: {query: `version:2 ${query}`.trim()},\n    }\n  );\n\n  promise.catch(() => {\n    addErrorMessage(t('Unable to load saved queries'));\n  });\n  return promise;\n}\n\nexport function fetchSavedQuery(\n  api: Client,\n  orgId: string,\n  queryId: string\n): Promise<SavedQuery> {\n  const promise: Promise<SavedQuery> = api.requestPromise(\n    `/organizations/${orgId}/discover/saved/${queryId}/`,\n    {\n      method: 'GET',\n    }\n  );\n\n  promise.catch(() => {\n    addErrorMessage(t('Unable to load saved query'));\n  });\n  return promise;\n}\n\nexport function createSavedQuery(\n  api: Client,\n  orgId: string,\n  query: NewQuery\n): Promise<SavedQuery> {\n  const promise: Promise<SavedQuery> = api.requestPromise(\n    `/organizations/${orgId}/discover/saved/`,\n    {\n      method: 'POST',\n      data: query,\n    }\n  );\n\n  promise.catch(() => {\n    addErrorMessage(t('Unable to create your saved query'));\n  });\n  return promise;\n}\n\nexport function updateSavedQuery(\n  api: Client,\n  orgId: string,\n  query: NewQuery\n): Promise<SavedQuery> {\n  const promise: Promise<SavedQuery> = api.requestPromise(\n    `/organizations/${orgId}/discover/saved/${query.id}/`,\n    {\n      method: 'PUT',\n      data: query,\n    }\n  );\n\n  promise.catch(() => {\n    addErrorMessage(t('Unable to update your saved query'));\n  });\n  return promise;\n}\n\nexport function updateSavedQueryVisit(\n  orgId: string,\n  queryId: string | string[]\n): Promise<void> {\n  // Create a new client so the request is not cancelled\n  const api = new Client();\n  const promise = api.requestPromise(\n    `/organizations/${orgId}/discover/saved/${queryId}/visit/`,\n    {\n      method: 'POST',\n    }\n  );\n\n  return promise;\n}\n\nexport function deleteSavedQuery(\n  api: Client,\n  orgId: string,\n  queryId: string\n): Promise<void> {\n  const promise: Promise<void> = api.requestPromise(\n    `/organizations/${orgId}/discover/saved/${queryId}/`,\n    {method: 'DELETE'}\n  );\n\n  promise.catch(() => {\n    addErrorMessage(t('Unable to delete the saved query'));\n  });\n  return promise;\n}\n","import * as React from 'react';\nimport {css} from '@emotion/react';\nimport styled from '@emotion/styled';\n\nimport Button from 'sentry/components/button';\nimport ButtonBar from 'sentry/components/buttonBar';\nimport {IconClose} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\n\nconst makeKey = (prefix: string) => `${prefix}-banner-dismissed`;\n\nfunction dismissBanner(bannerKey: string) {\n  localStorage.setItem(makeKey(bannerKey), 'true');\n}\n\nfunction useDismissable(bannerKey: string) {\n  const key = makeKey(bannerKey);\n  const [value, setValue] = React.useState(localStorage.getItem(key));\n\n  const dismiss = () => {\n    setValue('true');\n    dismissBanner(bannerKey);\n  };\n\n  return [value === 'true', dismiss] as const;\n}\n\ntype BannerWrapperProps = {\n  backgroundComponent?: React.ReactNode;\n  backgroundImg?: string;\n};\n\ntype Props = BannerWrapperProps & {\n  className?: string;\n  dismissKey?: string;\n  isDismissable?: boolean;\n  subtitle?: string;\n  title?: string;\n};\n\ntype BannerType = React.FC<Props> & {\n  /**\n   * Helper function to hide banners outside of their usage\n   */\n  dismiss: typeof dismissBanner;\n};\n\nconst Banner: BannerType = ({\n  title,\n  subtitle,\n  isDismissable = true,\n  dismissKey = 'generic-banner',\n  className,\n  backgroundImg,\n  backgroundComponent,\n  children,\n}) => {\n  const [dismissed, dismiss] = useDismissable(dismissKey);\n\n  if (dismissed) {\n    return null;\n  }\n\n  return (\n    <BannerWrapper backgroundImg={backgroundImg} className={className}>\n      {backgroundComponent}\n      {isDismissable ? <CloseButton onClick={dismiss} aria-label={t('Close')} /> : null}\n      <BannerContent>\n        <BannerTitle>{title}</BannerTitle>\n        <BannerSubtitle>{subtitle}</BannerSubtitle>\n        <StyledButtonBar gap={1}>{children}</StyledButtonBar>\n      </BannerContent>\n    </BannerWrapper>\n  );\n};\n\nBanner.dismiss = dismissBanner;\n\nconst BannerWrapper = styled('div')<BannerWrapperProps>`\n  ${p =>\n    p.backgroundImg\n      ? css`\n          background: url(${p.backgroundImg});\n          background-repeat: no-repeat;\n          background-size: cover;\n          background-position: center center;\n        `\n      : css`\n          background-color: ${p.theme.gray500};\n        `}\n  display: flex;\n  overflow: hidden;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  margin-bottom: ${space(2)};\n  box-shadow: ${p => p.theme.dropShadowLight};\n  border-radius: ${p => p.theme.borderRadius};\n  height: 180px;\n  color: ${p => p.theme.white};\n\n  @media (min-width: ${p => p.theme.breakpoints[0]}) {\n    height: 220px;\n  }\n`;\n\nconst BannerContent = styled('div')`\n  position: absolute;\n  display: grid;\n  justify-items: center;\n  grid-template-rows: repeat(3, max-content);\n  text-align: center;\n  padding: ${space(4)};\n`;\n\nconst BannerTitle = styled('h1')`\n  margin: 0;\n\n  @media (min-width: ${p => p.theme.breakpoints[0]}) {\n    font-size: 40px;\n  }\n`;\n\nconst BannerSubtitle = styled('div')`\n  margin: 0;\n\n  @media (min-width: ${p => p.theme.breakpoints[0]}) {\n    font-size: ${p => p.theme.fontSizeExtraLarge};\n  }\n`;\n\nconst StyledButtonBar = styled(ButtonBar)`\n  margin-top: ${space(2)};\n  width: fit-content;\n`;\n\nconst CloseButton = styled(Button)`\n  position: absolute;\n  display: block;\n  top: ${space(2)};\n  right: ${space(2)};\n  color: ${p => p.theme.white};\n  cursor: pointer;\n  z-index: 1;\n`;\n\nCloseButton.defaultProps = {\n  icon: <IconClose />,\n  ['aria-label']: t('Close'),\n  priority: 'link',\n  borderless: true,\n  size: 'xsmall',\n};\n\nexport default Banner;\n","import {useEffect, useState} from 'react';\n\nimport {Client} from 'sentry/api';\nimport {DateString, OrganizationSummary} from 'sentry/types';\nimport {getUtcDateString} from 'sentry/utils/dates';\nimport {TableData, TableDataWithTitle} from 'sentry/utils/discover/discoverQuery';\nimport EventView from 'sentry/utils/discover/eventView';\nimport {doDiscoverQuery} from 'sentry/utils/discover/genericDiscoverQuery';\n\ntype ChildrenArgs = {\n  errored: boolean;\n  loading: boolean;\n  reloading: boolean;\n  tableData?: TableDataWithTitle[];\n};\n\nconst EventsGeoRequest = ({\n  api,\n  organization,\n  yAxis,\n  query,\n  orderby,\n  projects,\n  period,\n  start,\n  end,\n  environments,\n  referrer,\n  children,\n}: {\n  api: Client;\n  children: (args: ChildrenArgs) => React.ReactElement;\n  end: DateString;\n  environments: string[];\n  organization: OrganizationSummary;\n  projects: number[];\n  query: string;\n  start: DateString;\n  yAxis: string | string[];\n  orderby?: string;\n  period?: string | null;\n  referrer?: string;\n}) => {\n  const eventView = EventView.fromSavedQuery({\n    id: undefined,\n    name: '',\n    version: 2,\n    fields: Array.isArray(yAxis) ? yAxis : [yAxis],\n    query,\n    orderby: orderby ?? '',\n    projects,\n    range: period ?? '',\n    start: start ? getUtcDateString(start) : undefined,\n    end: end ? getUtcDateString(end) : undefined,\n    environment: environments,\n  });\n  const [results, setResults] = useState(undefined as ChildrenArgs['tableData']);\n  const [reloading, setReloading] = useState(false);\n  const [errored, setErrored] = useState(false);\n  useEffect(() => {\n    setErrored(false);\n    if (results) {\n      setReloading(true);\n    }\n    doDiscoverQuery<TableData>(api, `/organizations/${organization.slug}/events-geo/`, {\n      ...eventView.generateQueryStringObject(),\n      referrer,\n    })\n      .then(discoverQueryResults => {\n        setResults([discoverQueryResults[0]] as TableDataWithTitle[]);\n        setReloading(false);\n      })\n      .catch(() => {\n        setErrored(true);\n        setReloading(false);\n      });\n  }, [query, yAxis, start, end, period, environments, projects]);\n  return children({\n    errored,\n    loading: !results && !errored,\n    reloading,\n    tableData: results,\n  });\n};\n\nexport default EventsGeoRequest;\n","import * as React from 'react';\nimport isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\n\nimport {doEventsRequest} from 'sentry/actionCreators/events';\nimport {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport {Client} from 'sentry/api';\nimport LoadingPanel from 'sentry/components/charts/loadingPanel';\nimport {\n  canIncludePreviousPeriod,\n  getPreviousSeriesName,\n  isMultiSeriesStats,\n} from 'sentry/components/charts/utils';\nimport {t} from 'sentry/locale';\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'sentry/types';\nimport {Series, SeriesDataUnit} from 'sentry/types/echarts';\nimport {stripEquationPrefix} from 'sentry/utils/discover/fields';\nimport {QueryBatching} from 'sentry/utils/performance/contexts/genericQueryBatcher';\n\nexport type TimeSeriesData = {\n  allTimeseriesData?: EventsStatsData;\n  comparisonTimeseriesData?: Series[];\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  originalTimeseriesData?: EventsStatsData;\n  previousTimeseriesData?: Series[] | null;\n  timeAggregatedData?: Series | {};\n  timeframe?: {end: number; start: number};\n  // timeseries data\n  timeseriesData?: Series[];\n  timeseriesTotals?: {count: number};\n};\n\ntype LoadingStatus = {\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n  loading: boolean;\n  reloading: boolean;\n  errorMessage?: string;\n};\n\nexport type RenderProps = LoadingStatus &\n  TimeSeriesData & {\n    results?: Series[]; // Chart with multiple series.\n  };\n\ntype DefaultProps = {\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Time delta for comparing intervals of alert metrics, in seconds\n   */\n  comparisonDelta?: number;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string | null;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  organization: OrganizationSummary;\n  /**\n   * Whether or not to include the last partial bucket. This happens for example when the\n   * current time is 11:26 and the last bucket ranges from 11:25-11:30. This means that\n   * the last bucket contains 1 minute worth of data while the rest contains 5 minutes.\n   *\n   * This flag indicates whether or not this last bucket should be included in the result.\n   */\n  partial: boolean;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n  /**\n   * Name used for display current series data set tooltip\n   */\n  currentSeriesNames?: string[];\n  /**\n   * List of environments to query\n   */\n  environment?: Readonly<string[]>;\n  /**\n   * Is query out of retention\n   */\n  expired?: boolean;\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Allows overridding the pathname.\n   */\n  generatePathname?: (org: OrganizationSummary) => string;\n  /**\n   * Hide error toast (used for pages which also query eventsV2)\n   */\n  hideError?: boolean;\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Query name used for displaying error toast if it is out of retention\n   */\n  name?: string;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  previousSeriesNames?: string[];\n  /**\n   * List of project ids to query\n   */\n  project?: Readonly<number[]>;\n  /**\n   * A container for query batching data and functions.\n   */\n  queryBatching?: QueryBatching;\n  /**\n   * Extra query parameters to be added.\n   */\n  queryExtras?: Record<string, string>;\n  /**\n   * A unique name for what's triggering this request, see organization_events_stats for an allowlist\n   */\n  referrer?: string;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * List of team ids to query\n   */\n  team?: Readonly<string | string[]>;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * Whether or not to zerofill results\n   */\n  withoutZerofill?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n};\n\ntype TimeAggregationProps =\n  | {includeTimeAggregation: true; timeAggregationSeriesName: string}\n  | {includeTimeAggregation?: false; timeAggregationSeriesName?: undefined};\n\nexport type EventsRequestProps = DefaultProps &\n  TimeAggregationProps &\n  EventsRequestPartialProps;\n\ntype EventsRequestState = {\n  errored: boolean;\n  fetchedWithPrevious: boolean;\n  reloading: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n  errorMessage?: string;\n};\n\nconst propNamesToIgnore = [\n  'api',\n  'children',\n  'organization',\n  'loading',\n  'queryBatching',\n  'generatePathname',\n];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nclass EventsRequest extends React.PureComponent<EventsRequestProps, EventsRequestState> {\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    comparisonDelta: undefined,\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n    fetchedWithPrevious: false,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, expired, name, hideError, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n      errorMessage: undefined,\n    }));\n\n    let errorMessage;\n    if (expired) {\n      errorMessage = t(\n        '%s has an invalid date range. Please try a more recent date range.',\n        name\n      );\n      addErrorMessage(errorMessage, {append: true});\n\n      this.setState({\n        errored: true,\n        errorMessage,\n      });\n    } else {\n      try {\n        api.clear();\n        timeseriesData = await doEventsRequest(api, props);\n      } catch (resp) {\n        if (resp && resp.responseJSON && resp.responseJSON.detail) {\n          errorMessage = resp.responseJSON.detail;\n        } else {\n          errorMessage = t('Error loading chart data');\n        }\n        if (!hideError) {\n          addErrorMessage(errorMessage);\n        }\n        this.setState({\n          errored: true,\n          errorMessage,\n        });\n      }\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n      fetchedWithPrevious: props.includePrevious,\n    });\n  };\n\n  /**\n   * Retrieves data set for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData\n  ): {current: EventsStatsData; previous: EventsStatsData | null} => {\n    const {fetchedWithPrevious} = this.state;\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod =\n      fetchedWithPrevious || canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null,\n    seriesName?: string\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: seriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n      stack: 'previous',\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(data: EventsStatsData, seriesName?: string): Series[] {\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0),\n        })),\n      },\n    ];\n  }\n\n  /**\n   * Transforms comparisonCount in query response into timeseries data to be used in a comparison chart for change alerts\n   */\n  transformComparisonTimeseriesData(data: EventsStatsData): Series[] {\n    return [\n      {\n        seriesName: 'comparisonCount()',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce(\n            (acc, {comparisonCount}) => acc + (comparisonCount ?? 0),\n            0\n          ),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats, seriesIndex: number = 0, seriesName?: string) {\n    const {data, totals} = response;\n    const {\n      includeTransformedData,\n      includeTimeAggregation,\n      timeAggregationSeriesName,\n      currentSeriesNames,\n      previousSeriesNames,\n      comparisonDelta,\n    } = this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(\n          current,\n          seriesName ?? currentSeriesNames?.[seriesIndex]\n        )\n      : [];\n    const transformedComparisonData =\n      includeTransformedData && comparisonDelta\n        ? this.transformComparisonTimeseriesData(current)\n        : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(\n          current,\n          previous,\n          (seriesName ? getPreviousSeriesName(seriesName) : undefined) ??\n            previousSeriesNames?.[seriesIndex]\n        )\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    const timeframe =\n      response.start && response.end\n        ? !previous\n          ? {\n              start: response.start * 1000,\n              end: response.end * 1000,\n            }\n          : {\n              // Find the midpoint of start & end since previous includes 2x data\n              start: (response.start + response.end) * 500,\n              end: response.end * 1000,\n            }\n        : undefined;\n    return {\n      data: transformedData,\n      comparisonData: transformedComparisonData,\n      allData: data,\n      originalData: current,\n      totals,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n      timeframe,\n    };\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {timeseriesData, reloading, errored, errorMessage} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n    if (isMultiSeriesStats(timeseriesData)) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      let timeframe: {end: number; start: number} | undefined = undefined;\n      const sortedTimeseriesData = Object.keys(timeseriesData)\n        .map((seriesName: string, index: number): [number, Series, Series | null] => {\n          const seriesData: EventsStats = timeseriesData[seriesName];\n          const processedData = this.processData(\n            seriesData,\n            index,\n            stripEquationPrefix(seriesName)\n          );\n          if (!timeframe) {\n            timeframe = processedData.timeframe;\n          }\n          return [\n            seriesData.order || 0,\n            processedData.data[0],\n            processedData.previousData,\n          ];\n        })\n        .sort((a, b) => a[0] - b[0]);\n      const results: Series[] = sortedTimeseriesData.map(item => {\n        return item[1];\n      });\n      const previousTimeseriesData: Series[] | undefined = sortedTimeseriesData.some(\n        item => item[2] === null\n      )\n        ? undefined\n        : sortedTimeseriesData.map(item => {\n            return item[2] as Series;\n          });\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        errorMessage,\n        results,\n        timeframe,\n        previousTimeseriesData,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n    if (timeseriesData) {\n      const {\n        data: transformedTimeseriesData,\n        comparisonData: transformedComparisonTimeseriesData,\n        allData: allTimeseriesData,\n        originalData: originalTimeseriesData,\n        totals: timeseriesTotals,\n        originalPreviousData: originalPreviousTimeseriesData,\n        previousData: previousTimeseriesData,\n        timeAggregatedData,\n        timeframe,\n      } = this.processData(timeseriesData);\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        errorMessage,\n        // timeseries data\n        timeseriesData: transformedTimeseriesData,\n        comparisonTimeseriesData: transformedComparisonTimeseriesData,\n        allTimeseriesData,\n        originalTimeseriesData,\n        timeseriesTotals,\n        originalPreviousTimeseriesData,\n        previousTimeseriesData: previousTimeseriesData\n          ? [previousTimeseriesData]\n          : previousTimeseriesData,\n        timeAggregatedData,\n        timeframe,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n    return children({\n      loading,\n      reloading,\n      errored,\n      errorMessage,\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","import {Layout} from 'react-grid-layout';\n\nimport {User} from 'sentry/types';\n\n// Max widgets per dashboard we are currently willing\n// to allow to limit the load on snuba from the\n// parallel requests. Somewhat arbitrary\n// limit that can be changed if necessary.\nexport const MAX_WIDGETS = 30;\n\nexport enum DisplayType {\n  AREA = 'area',\n  BAR = 'bar',\n  LINE = 'line',\n  TABLE = 'table',\n  WORLD_MAP = 'world_map',\n  BIG_NUMBER = 'big_number',\n  STACKED_AREA = 'stacked_area',\n  TOP_N = 'top_n',\n}\n\nexport enum WidgetType {\n  DISCOVER = 'discover',\n  ISSUE = 'issue',\n  METRICS = 'metrics',\n}\n\nexport type WidgetQuery = {\n  conditions: string;\n  fields: string[];\n  name: string;\n  orderby: string;\n};\n\nexport type Widget = {\n  displayType: DisplayType;\n  interval: string;\n  queries: WidgetQuery[];\n  title: string;\n  id?: string;\n  layout?: WidgetLayout | null;\n  tempId?: string;\n  widgetType?: WidgetType;\n};\n\n// We store an explicit set of keys in the backend now\nexport type WidgetLayout = Pick<Layout, 'h' | 'w' | 'x' | 'y'> & {\n  minH: number;\n};\n\nexport type WidgetPreview = {\n  displayType: DisplayType;\n  layout: WidgetLayout | null;\n};\n\n/**\n * The response shape from dashboard list endpoint\n */\nexport type DashboardListItem = {\n  id: string;\n  title: string;\n  widgetDisplay: DisplayType[];\n  widgetPreview: WidgetPreview[];\n  createdBy?: User;\n  dateCreated?: string;\n};\n\n/**\n * Saved dashboard with widgets\n */\nexport type DashboardDetails = {\n  dateCreated: string;\n  id: string;\n  title: string;\n  widgets: Widget[];\n  createdBy?: User;\n};\n\nexport enum DashboardState {\n  VIEW = 'view',\n  EDIT = 'edit',\n  CREATE = 'create',\n  PENDING_DELETE = 'pending_delete',\n  PREVIEW = 'preview',\n}\n\n// where we launch the dashboard widget from\nexport enum DashboardWidgetSource {\n  DISCOVERV2 = 'discoverv2',\n  DASHBOARDS = 'dashboards',\n  LIBRARY = 'library',\n  ISSUE_DETAILS = 'issueDetail',\n}\n","import {\n  createSavedQuery,\n  deleteSavedQuery,\n  updateSavedQuery,\n} from 'sentry/actionCreators/discoverSavedQueries';\nimport {addErrorMessage, addSuccessMessage} from 'sentry/actionCreators/indicator';\nimport {Client} from 'sentry/api';\nimport {t} from 'sentry/locale';\nimport {NewQuery, Organization, SavedQuery} from 'sentry/types';\nimport {trackAnalyticsEvent} from 'sentry/utils/analytics';\nimport EventView from 'sentry/utils/discover/eventView';\nimport {DisplayModes} from 'sentry/utils/discover/types';\nimport {DisplayType} from 'sentry/views/dashboardsV2/types';\n\nexport function handleCreateQuery(\n  api: Client,\n  organization: Organization,\n  eventView: EventView,\n  yAxis: string[],\n  // True if this is a brand new query being saved\n  // False if this is a modification from a saved query\n  isNewQuery: boolean = true\n): Promise<SavedQuery> {\n  const payload = eventView.toNewQuery();\n  payload.yAxis = yAxis;\n\n  trackAnalyticsEvent({\n    ...getAnalyticsCreateEventKeyName(isNewQuery, 'request'),\n    organization_id: parseInt(organization.id, 10),\n    ...extractAnalyticsQueryFields(payload),\n  });\n\n  const promise = createSavedQuery(api, organization.slug, payload);\n\n  promise\n    .then((savedQuery: SavedQuery) => {\n      addSuccessMessage(t('Query saved'));\n\n      trackAnalyticsEvent({\n        ...getAnalyticsCreateEventKeyName(isNewQuery, 'success'),\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(payload),\n      });\n\n      return savedQuery;\n    })\n    .catch((err: Error) => {\n      addErrorMessage(t('Query not saved'));\n\n      trackAnalyticsEvent({\n        ...getAnalyticsCreateEventKeyName(isNewQuery, 'failed'),\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(payload),\n        error:\n          (err && err.message) ||\n          `Could not save a ${isNewQuery ? 'new' : 'existing'} query`,\n      });\n    });\n\n  return promise;\n}\n\nconst EVENT_NAME_EXISTING_MAP = {\n  request: 'Discoverv2: Request to save a saved query as a new query',\n  success: 'Discoverv2: Successfully saved a saved query as a new query',\n  failed: 'Discoverv2: Failed to save a saved query as a new query',\n};\nconst EVENT_NAME_NEW_MAP = {\n  request: 'Discoverv2: Request to save a new query',\n  success: 'Discoverv2: Successfully saved a new query',\n  failed: 'Discoverv2: Failed to save a new query',\n};\n\nexport function handleUpdateQuery(\n  api: Client,\n  organization: Organization,\n  eventView: EventView,\n  yAxis: string[]\n): Promise<SavedQuery> {\n  const payload = eventView.toNewQuery();\n  payload.yAxis = yAxis;\n\n  if (!eventView.name) {\n    addErrorMessage(t('Please name your query'));\n    return Promise.reject();\n  }\n\n  trackAnalyticsEvent({\n    eventKey: 'discover_v2.update_query_request',\n    eventName: 'Discoverv2: Request to update a saved query',\n    organization_id: parseInt(organization.id, 10),\n    ...extractAnalyticsQueryFields(payload),\n  });\n\n  const promise = updateSavedQuery(api, organization.slug, payload);\n\n  promise\n    .then((savedQuery: SavedQuery) => {\n      addSuccessMessage(t('Query updated'));\n\n      trackAnalyticsEvent({\n        eventKey: 'discover_v2.update_query_success',\n        eventName: 'Discoverv2: Successfully updated a saved query',\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(payload),\n      });\n      // NOTE: there is no need to convert _saved into an EventView and push it\n      //       to the browser history, since this.props.eventView already\n      //       derives from location.\n\n      return savedQuery;\n    })\n    .catch((err: Error) => {\n      addErrorMessage(t('Query not updated'));\n\n      trackAnalyticsEvent({\n        eventKey: 'discover_v2.update_query_failed',\n        eventName: 'Discoverv2: Failed to update a saved query',\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(payload),\n        error: (err && err.message) || 'Failed to update a query',\n      });\n    });\n\n  return promise;\n}\n\n/**\n * Essentially the same as handleUpdateQuery, but specifically for changing the\n * name of the query\n */\nexport function handleUpdateQueryName(\n  api: Client,\n  organization: Organization,\n  eventView: EventView\n) {\n  const payload = eventView.toNewQuery();\n\n  trackAnalyticsEvent({\n    eventKey: 'discover_v2.update_query_name_request',\n    eventName: \"Discoverv2: Request to update a saved query's name\",\n    organization_id: parseInt(organization.id, 10),\n    ...extractAnalyticsQueryFields(payload),\n  });\n\n  const promise = updateSavedQuery(api, organization.slug, payload);\n\n  promise\n    .then(_saved => {\n      addSuccessMessage(t('Query name saved'));\n\n      trackAnalyticsEvent({\n        eventKey: 'discover_v2.update_query_name_success',\n        eventName: \"Discoverv2: Successfully updated a saved query's name\",\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(payload),\n      });\n    })\n    .catch((err: Error) => {\n      addErrorMessage(t('Query name not saved'));\n\n      trackAnalyticsEvent({\n        eventKey: 'discover_v2.update_query_failed',\n        eventName: \"Discoverv2: Failed to update a saved query's name\",\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(payload),\n        error: (err && err.message) || 'Failed to update a query name',\n      });\n    });\n\n  return promise;\n}\n\nexport function handleDeleteQuery(\n  api: Client,\n  organization: Organization,\n  eventView: EventView\n): Promise<void> {\n  trackAnalyticsEvent({\n    eventKey: 'discover_v2.delete_query_request',\n    eventName: 'Discoverv2: Request to delete a saved query',\n    organization_id: parseInt(organization.id, 10),\n    ...extractAnalyticsQueryFields(eventView.toNewQuery()),\n  });\n\n  const promise = deleteSavedQuery(api, organization.slug, eventView.id!);\n\n  promise\n    .then(() => {\n      addSuccessMessage(t('Query deleted'));\n\n      trackAnalyticsEvent({\n        eventKey: 'discover_v2.delete_query_success',\n        eventName: 'Discoverv2: Successfully deleted a saved query',\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(eventView.toNewQuery()),\n      });\n    })\n    .catch((err: Error) => {\n      addErrorMessage(t('Query not deleted'));\n\n      trackAnalyticsEvent({\n        eventKey: 'discover_v2.delete_query_failed',\n        eventName: 'Discoverv2: Failed to delete a saved query',\n        organization_id: parseInt(organization.id, 10),\n        ...extractAnalyticsQueryFields(eventView.toNewQuery()),\n        error: (err && err.message) || 'Failed to delete query',\n      });\n    });\n\n  return promise;\n}\n\nexport function getAnalyticsCreateEventKeyName(\n  // True if this is a brand new query being saved\n  // False if this is a modification from a saved query\n  isNewQuery: boolean,\n  type: 'request' | 'success' | 'failed'\n) {\n  const eventKey = isNewQuery\n    ? 'discover_v2.save_new_query_' + type\n    : 'discover_v2.save_existing_query_' + type;\n\n  const eventName = isNewQuery ? EVENT_NAME_NEW_MAP[type] : EVENT_NAME_EXISTING_MAP[type];\n\n  return {\n    eventKey,\n    eventName,\n  };\n}\n\n/**\n * Takes in a DiscoverV2 NewQuery object and returns a Partial containing\n * the desired fields to populate into reload analytics\n */\nexport function extractAnalyticsQueryFields(payload: NewQuery): Partial<NewQuery> {\n  const {projects, fields, query} = payload;\n  return {\n    projects,\n    fields,\n    query,\n  };\n}\n\nexport function displayModeToDisplayType(displayMode: DisplayModes): DisplayType {\n  switch (displayMode) {\n    case DisplayModes.BAR:\n      return DisplayType.BAR;\n    case DisplayModes.WORLDMAP:\n      return DisplayType.WORLD_MAP;\n    case DisplayModes.TOP5:\n      return DisplayType.TOP_N;\n    default:\n      return DisplayType.LINE;\n  }\n}\n"],"names":["fetchSavedQuery","api","orgId","queryId","promise","requestPromise","method","catch","addErrorMessage","t","createSavedQuery","query","data","updateSavedQuery","id","updateSavedQueryVisit","Client","deleteSavedQuery","makeKey","prefix","dismissBanner","bannerKey","localStorage","setItem","Banner","title","subtitle","isDismissable","dismissKey","className","backgroundImg","backgroundComponent","children","dismissed","dismiss","key","value","setValue","React","getItem","useDismissable","BannerWrapper","CloseButton","onClick","BannerContent","BannerTitle","BannerSubtitle","StyledButtonBar","gap","p","css","theme","gray500","space","dropShadowLight","borderRadius","white","breakpoints","fontSizeExtraLarge","ButtonBar","Button","defaultProps","icon","priority","borderless","size","organization","yAxis","orderby","projects","period","start","end","environments","referrer","eventView","EventView","undefined","name","version","fields","Array","isArray","range","getUtcDateString","environment","results","setResults","useState","reloading","setReloading","errored","setErrored","useEffect","doDiscoverQuery","slug","generateQueryStringObject","then","discoverQueryResults","loading","tableData","propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","includes","EventsRequest","this","timeseriesData","fetchedWithPrevious","async","confirmedQuery","expired","hideError","errorMessage","setState","state","append","clear","doEventsRequest","resp","responseJSON","detail","unmounting","includePrevious","hasPreviousPeriod","canIncludePreviousPeriod","dataMiddleIndex","Math","floor","length","current","slice","previous","componentDidMount","fetchData","componentDidUpdate","prevProps","isEqual","componentWillUnmount","calculateTotalsPerTimestamp","getName","timestamp","map","i","countArray","reduce","acc","count","transformPreviousPeriodData","seriesName","_timestamp","_countArray","stack","transformAggregatedTimeseries","transformTimeseriesData","countsForTimestamp","transformComparisonTimeseriesData","comparisonCount","processData","response","seriesIndex","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","currentSeriesNames","previousSeriesNames","comparisonDelta","getData","comparisonData","allData","originalData","originalPreviousData","previousData","getPreviousSeriesName","timeAggregatedData","timeframe","render","showLoading","isMultiSeriesStats","sortedTimeseriesData","Object","keys","index","seriesData","processedData","stripEquationPrefix","order","sort","a","b","item","previousTimeseriesData","some","transformedTimeseriesData","transformedComparisonTimeseriesData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","comparisonTimeseriesData","interval","limit","MAX_WIDGETS","DisplayType","WidgetType","DashboardState","DashboardWidgetSource","handleCreateQuery","isNewQuery","payload","toNewQuery","trackAnalyticsEvent","getAnalyticsCreateEventKeyName","organization_id","parseInt","extractAnalyticsQueryFields","savedQuery","addSuccessMessage","err","error","message","EVENT_NAME_EXISTING_MAP","request","success","failed","EVENT_NAME_NEW_MAP","handleUpdateQuery","Promise","reject","eventKey","eventName","handleUpdateQueryName","_saved","handleDeleteQuery","type","displayModeToDisplayType","displayMode","DisplayModes"],"sourceRoot":""}