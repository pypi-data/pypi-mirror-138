"""
    traQ v3

    traQ v3 API  # noqa: E501

    The version of the OpenAPI document: 3.0
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from traq.api_client import ApiClient, Endpoint as _Endpoint
from traq.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from traq.model.message import Message
from traq.model.message_clip import MessageClip
from traq.model.message_pin import MessagePin
from traq.model.message_search_result import MessageSearchResult
from traq.model.message_stamp import MessageStamp
from traq.model.post_message_request import PostMessageRequest
from traq.model.post_message_stamp_request import PostMessageStampRequest


class MessageApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.add_message_stamp_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}/stamps/{stampId}',
                'operation_id': 'add_message_stamp',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                    'stamp_id',
                    'post_message_stamp_request',
                ],
                'required': [
                    'message_id',
                    'stamp_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                    'stamp_id':
                        (str,),
                    'post_message_stamp_request':
                        (PostMessageStampRequest,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                    'stamp_id': 'stampId',
                },
                'location_map': {
                    'message_id': 'path',
                    'stamp_id': 'path',
                    'post_message_stamp_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_pin_endpoint = _Endpoint(
            settings={
                'response_type': (MessagePin,),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}/pin',
                'operation_id': 'create_pin',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_message_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}',
                'operation_id': 'delete_message',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.edit_message_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}',
                'operation_id': 'edit_message',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                    'post_message_request',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                    'post_message_request':
                        (PostMessageRequest,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                    'post_message_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_direct_messages_endpoint = _Endpoint(
            settings={
                'response_type': ([Message],),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/users/{userId}/messages',
                'operation_id': 'get_direct_messages',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'limit',
                    'offset',
                    'since',
                    'until',
                    'inclusive',
                    'order',
                ],
                'required': [
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'order',
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 200,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                    ('order',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                    'since':
                        (datetime,),
                    'until':
                        (datetime,),
                    'inclusive':
                        (bool,),
                    'order':
                        (str,),
                },
                'attribute_map': {
                    'user_id': 'userId',
                    'limit': 'limit',
                    'offset': 'offset',
                    'since': 'since',
                    'until': 'until',
                    'inclusive': 'inclusive',
                    'order': 'order',
                },
                'location_map': {
                    'user_id': 'path',
                    'limit': 'query',
                    'offset': 'query',
                    'since': 'query',
                    'until': 'query',
                    'inclusive': 'query',
                    'order': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_message_endpoint = _Endpoint(
            settings={
                'response_type': (Message,),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}',
                'operation_id': 'get_message',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_message_clips_endpoint = _Endpoint(
            settings={
                'response_type': ([MessageClip],),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}/clips',
                'operation_id': 'get_message_clips',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_message_stamps_endpoint = _Endpoint(
            settings={
                'response_type': ([MessageStamp],),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}/stamps',
                'operation_id': 'get_message_stamps',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_messages_endpoint = _Endpoint(
            settings={
                'response_type': ([Message],),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/channels/{channelId}/messages',
                'operation_id': 'get_messages',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'limit',
                    'offset',
                    'since',
                    'until',
                    'inclusive',
                    'order',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'order',
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 200,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                    ('order',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                    'since':
                        (datetime,),
                    'until':
                        (datetime,),
                    'inclusive':
                        (bool,),
                    'order':
                        (str,),
                },
                'attribute_map': {
                    'channel_id': 'channelId',
                    'limit': 'limit',
                    'offset': 'offset',
                    'since': 'since',
                    'until': 'until',
                    'inclusive': 'inclusive',
                    'order': 'order',
                },
                'location_map': {
                    'channel_id': 'path',
                    'limit': 'query',
                    'offset': 'query',
                    'since': 'query',
                    'until': 'query',
                    'inclusive': 'query',
                    'order': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_pin_endpoint = _Endpoint(
            settings={
                'response_type': (MessagePin,),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}/pin',
                'operation_id': 'get_pin',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.post_direct_message_endpoint = _Endpoint(
            settings={
                'response_type': (Message,),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/users/{userId}/messages',
                'operation_id': 'post_direct_message',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'post_message_request',
                ],
                'required': [
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'post_message_request':
                        (PostMessageRequest,),
                },
                'attribute_map': {
                    'user_id': 'userId',
                },
                'location_map': {
                    'user_id': 'path',
                    'post_message_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.post_message_endpoint = _Endpoint(
            settings={
                'response_type': (Message,),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/channels/{channelId}/messages',
                'operation_id': 'post_message',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'post_message_request',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'post_message_request':
                        (PostMessageRequest,),
                },
                'attribute_map': {
                    'channel_id': 'channelId',
                },
                'location_map': {
                    'channel_id': 'path',
                    'post_message_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.remove_message_stamp_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}/stamps/{stampId}',
                'operation_id': 'remove_message_stamp',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                    'stamp_id',
                ],
                'required': [
                    'message_id',
                    'stamp_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                    'stamp_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                    'stamp_id': 'stampId',
                },
                'location_map': {
                    'message_id': 'path',
                    'stamp_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.remove_pin_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages/{messageId}/pin',
                'operation_id': 'remove_pin',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'message_id',
                ],
                'required': [
                    'message_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'message_id':
                        (str,),
                },
                'attribute_map': {
                    'message_id': 'messageId',
                },
                'location_map': {
                    'message_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [],
                'content_type': [],
            },
            api_client=api_client
        )
        self.search_messages_endpoint = _Endpoint(
            settings={
                'response_type': (MessageSearchResult,),
                'auth': [
                    'OAuth2'
                ],
                'endpoint_path': '/messages',
                'operation_id': 'search_messages',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'word',
                    'after',
                    'before',
                    '_in',
                    'to',
                    '_from',
                    'citation',
                    'bot',
                    'has_url',
                    'has_attachments',
                    'has_image',
                    'has_video',
                    'has_audio',
                    'limit',
                    'offset',
                    'sort',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'sort',
                ],
                'validation': [
                    'limit',
                    'offset',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 100,
                        'inclusive_minimum': 1,
                    },
                    ('offset',): {

                        'inclusive_maximum': 9900,
                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                    ('sort',): {

                        "CREATEDAT": "createdAt",
                        "-CREATEDAT": "-createdAt",
                        "UPDATEDAT": "updatedAt",
                        "-UPDATEDAT": "-updatedAt"
                    },
                },
                'openapi_types': {
                    'word':
                        (str,),
                    'after':
                        (datetime,),
                    'before':
                        (datetime,),
                    '_in':
                        (str,),
                    'to':
                        (str,),
                    '_from':
                        (str,),
                    'citation':
                        (str,),
                    'bot':
                        (bool,),
                    'has_url':
                        (bool,),
                    'has_attachments':
                        (bool,),
                    'has_image':
                        (bool,),
                    'has_video':
                        (bool,),
                    'has_audio':
                        (bool,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                },
                'attribute_map': {
                    'word': 'word',
                    'after': 'after',
                    'before': 'before',
                    '_in': 'in',
                    'to': 'to',
                    '_from': 'from',
                    'citation': 'citation',
                    'bot': 'bot',
                    'has_url': 'hasURL',
                    'has_attachments': 'hasAttachments',
                    'has_image': 'hasImage',
                    'has_video': 'hasVideo',
                    'has_audio': 'hasAudio',
                    'limit': 'limit',
                    'offset': 'offset',
                    'sort': 'sort',
                },
                'location_map': {
                    'word': 'query',
                    'after': 'query',
                    'before': 'query',
                    '_in': 'query',
                    'to': 'query',
                    '_from': 'query',
                    'citation': 'query',
                    'bot': 'query',
                    'has_url': 'query',
                    'has_attachments': 'query',
                    'has_image': 'query',
                    'has_video': 'query',
                    'has_audio': 'query',
                    'limit': 'query',
                    'offset': 'query',
                    'sort': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )

    def add_message_stamp(
        self,
        message_id,
        stamp_id,
        **kwargs
    ):
        """スタンプを押す  # noqa: E501

        指定したメッセージに指定したスタンプを押します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_message_stamp(message_id, stamp_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID
            stamp_id (str): スタンプUUID

        Keyword Args:
            post_message_stamp_request (PostMessageStampRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        kwargs['stamp_id'] = \
            stamp_id
        return self.add_message_stamp_endpoint.call_with_http_info(**kwargs)

    def create_pin(
        self,
        message_id,
        **kwargs
    ):
        """ピン留めする  # noqa: E501

        指定したメッセージをピン留めします。 アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_pin(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MessagePin
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.create_pin_endpoint.call_with_http_info(**kwargs)

    def delete_message(
        self,
        message_id,
        **kwargs
    ):
        """メッセージを削除  # noqa: E501

        指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_message(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.delete_message_endpoint.call_with_http_info(**kwargs)

    def edit_message(
        self,
        message_id,
        **kwargs
    ):
        """メッセージを編集  # noqa: E501

        指定したメッセージを編集します。 自身が投稿したメッセージのみ編集することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_message(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            post_message_request (PostMessageRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.edit_message_endpoint.call_with_http_info(**kwargs)

    def get_direct_messages(
        self,
        user_id,
        **kwargs
    ):
        """ダイレクトメッセージのリストを取得  # noqa: E501

        指定したユーザーとのダイレクトメッセージのリストを取得します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_direct_messages(user_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str): ユーザーUUID

        Keyword Args:
            limit (int): 取得する件数. [optional]
            offset (int): 取得するオフセット. [optional] if omitted the server will use the default value of 0
            since (datetime): 取得する時間範囲の開始日時. [optional] if omitted the server will use the default value of dateutil_parser('0000-01-01T00:00:00Z')
            until (datetime): 取得する時間範囲の終了日時. [optional]
            inclusive (bool): 範囲の端を含めるかどうか. [optional] if omitted the server will use the default value of False
            order (str): 昇順か降順か. [optional] if omitted the server will use the default value of "desc"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [Message]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        return self.get_direct_messages_endpoint.call_with_http_info(**kwargs)

    def get_message(
        self,
        message_id,
        **kwargs
    ):
        """メッセージを取得  # noqa: E501

        指定したメッセージを取得します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_message(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Message
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.get_message_endpoint.call_with_http_info(**kwargs)

    def get_message_clips(
        self,
        message_id,
        **kwargs
    ):
        """自分のクリップを取得  # noqa: E501

        対象のメッセージの自分のクリップの一覧を返します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_message_clips(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [MessageClip]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.get_message_clips_endpoint.call_with_http_info(**kwargs)

    def get_message_stamps(
        self,
        message_id,
        **kwargs
    ):
        """メッセージのスタンプリストを取得  # noqa: E501

        指定したメッセージに押されているスタンプのリストを取得します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_message_stamps(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [MessageStamp]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.get_message_stamps_endpoint.call_with_http_info(**kwargs)

    def get_messages(
        self,
        channel_id,
        **kwargs
    ):
        """チャンネルメッセージのリストを取得  # noqa: E501

        指定したチャンネルのメッセージのリストを取得します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_messages(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): チャンネルUUID

        Keyword Args:
            limit (int): 取得する件数. [optional]
            offset (int): 取得するオフセット. [optional] if omitted the server will use the default value of 0
            since (datetime): 取得する時間範囲の開始日時. [optional] if omitted the server will use the default value of dateutil_parser('0000-01-01T00:00:00Z')
            until (datetime): 取得する時間範囲の終了日時. [optional]
            inclusive (bool): 範囲の端を含めるかどうか. [optional] if omitted the server will use the default value of False
            order (str): 昇順か降順か. [optional] if omitted the server will use the default value of "desc"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [Message]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.get_messages_endpoint.call_with_http_info(**kwargs)

    def get_pin(
        self,
        message_id,
        **kwargs
    ):
        """ピン留めを取得  # noqa: E501

        指定したメッセージのピン留め情報を取得します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_pin(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MessagePin
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.get_pin_endpoint.call_with_http_info(**kwargs)

    def post_direct_message(
        self,
        user_id,
        **kwargs
    ):
        """ダイレクトメッセージを送信  # noqa: E501

        指定したユーザーにダイレクトメッセージを送信します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_direct_message(user_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str): ユーザーUUID

        Keyword Args:
            post_message_request (PostMessageRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Message
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        return self.post_direct_message_endpoint.call_with_http_info(**kwargs)

    def post_message(
        self,
        channel_id,
        **kwargs
    ):
        """チャンネルにメッセージを投稿  # noqa: E501

        指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。 アーカイブされているチャンネルに投稿することはできません。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_message(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): チャンネルUUID

        Keyword Args:
            post_message_request (PostMessageRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Message
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.post_message_endpoint.call_with_http_info(**kwargs)

    def remove_message_stamp(
        self,
        message_id,
        stamp_id,
        **kwargs
    ):
        """スタンプを消す  # noqa: E501

        指定したメッセージから指定した自身が押したスタンプを削除します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_message_stamp(message_id, stamp_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID
            stamp_id (str): スタンプUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        kwargs['stamp_id'] = \
            stamp_id
        return self.remove_message_stamp_endpoint.call_with_http_info(**kwargs)

    def remove_pin(
        self,
        message_id,
        **kwargs
    ):
        """ピン留めを外す  # noqa: E501

        指定したメッセージのピン留めを外します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_pin(message_id, async_req=True)
        >>> result = thread.get()

        Args:
            message_id (str): メッセージUUID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['message_id'] = \
            message_id
        return self.remove_pin_endpoint.call_with_http_info(**kwargs)

    def search_messages(
        self,
        **kwargs
    ):
        """メッセージを検索  # noqa: E501

        メッセージを検索します。  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_messages(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            word (str): 検索ワード Simple-Query-String-Syntaxをパースして検索します . [optional]
            after (datetime): 投稿日時が指定日時より後. [optional]
            before (datetime): 投稿日時が指定日時より前. [optional]
            _in (str): メッセージが投稿されたチャンネル. [optional]
            to (str): メンションされたユーザー. [optional]
            _from (str): メッセージを投稿したユーザー. [optional]
            citation (str): 引用しているメッセージ. [optional]
            bot (bool): メッセージを投稿したユーザーがBotかどうか. [optional]
            has_url (bool): メッセージがURLを含むか. [optional]
            has_attachments (bool): メッセージが添付ファイルを含むか. [optional]
            has_image (bool): メッセージが画像を含むか. [optional]
            has_video (bool): メッセージが動画を含むか. [optional]
            has_audio (bool): メッセージが音声ファイルを含むか. [optional]
            limit (int): 検索結果から取得するメッセージの最大件数. [optional]
            offset (int): 検索結果から取得するメッセージのオフセット. [optional]
            sort (str): ソート順 (作成日時が新しい `createdAt`, 作成日時が古い `-createdAt`, 更新日時が新しい `updatedAt`, 更新日時が古い `-updatedAt`). [optional] if omitted the server will use the default value of "-createdAt"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MessageSearchResult
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.search_messages_endpoint.call_with_http_info(**kwargs)

