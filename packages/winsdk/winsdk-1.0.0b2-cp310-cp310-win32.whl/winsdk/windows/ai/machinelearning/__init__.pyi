# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.2

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt

try:
    import winsdk.windows.foundation
except Exception:
    pass

try:
    import winsdk.windows.foundation.collections
except Exception:
    pass

try:
    import winsdk.windows.graphics
except Exception:
    pass

try:
    import winsdk.windows.graphics.directx.direct3d11
except Exception:
    pass

try:
    import winsdk.windows.graphics.imaging
except Exception:
    pass

try:
    import winsdk.windows.media
except Exception:
    pass

try:
    import winsdk.windows.storage
except Exception:
    pass

try:
    import winsdk.windows.storage.streams
except Exception:
    pass

class LearningModelDeviceKind(enum.IntEnum):
    DEFAULT = 0
    CPU = 1
    DIRECT_X = 2
    DIRECT_X_HIGH_PERFORMANCE = 3
    DIRECT_X_MIN_POWER = 4

class LearningModelFeatureKind(enum.IntEnum):
    TENSOR = 0
    SEQUENCE = 1
    MAP = 2
    IMAGE = 3

class LearningModelPixelRange(enum.IntEnum):
    ZERO_TO255 = 0
    ZERO_TO_ONE = 1
    MINUS_ONE_TO_ONE = 2

class TensorKind(enum.IntEnum):
    UNDEFINED = 0
    FLOAT = 1
    UINT8 = 2
    INT8 = 3
    UINT16 = 4
    INT16 = 5
    INT32 = 6
    INT64 = 7
    STRING = 8
    BOOLEAN = 9
    FLOAT16 = 10
    DOUBLE = 11
    UINT32 = 12
    UINT64 = 13
    COMPLEX64 = 14
    COMPLEX128 = 15

class ImageFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.Object):
    bitmap_alpha_mode: winsdk.windows.graphics.imaging.BitmapAlphaMode
    bitmap_pixel_format: winsdk.windows.graphics.imaging.BitmapPixelFormat
    height: _winrt.UInt32
    width: _winrt.UInt32
    pixel_range: LearningModelPixelRange
    description: str
    is_required: _winrt.Boolean
    kind: LearningModelFeatureKind
    name: str
    @staticmethod
    def _from(obj: _winrt.Object) -> ImageFeatureDescriptor: ...

class ImageFeatureValue(ILearningModelFeatureValue, _winrt.Object):
    video_frame: winsdk.windows.media.VideoFrame
    kind: LearningModelFeatureKind
    @staticmethod
    def _from(obj: _winrt.Object) -> ImageFeatureValue: ...
    @typing.overload
    @staticmethod
    def create_from_video_frame(image: winsdk.windows.media.VideoFrame) -> ImageFeatureValue: ...

class LearningModel(winsdk.windows.foundation.IClosable, _winrt.Object):
    author: str
    description: str
    domain: str
    input_features: winsdk.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]
    metadata: winsdk.windows.foundation.collections.IMapView[str, str]
    name: str
    output_features: winsdk.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]
    version: _winrt.Int64
    @staticmethod
    def _from(obj: _winrt.Object) -> LearningModel: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def load_from_file_path(file_path: str) -> LearningModel: ...
    @typing.overload
    @staticmethod
    def load_from_file_path(file_path: str, operator_provider: ILearningModelOperatorProvider) -> LearningModel: ...
    @typing.overload
    @staticmethod
    def load_from_storage_file_async(model_file: winsdk.windows.storage.IStorageFile) -> winsdk.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_storage_file_async(model_file: winsdk.windows.storage.IStorageFile, operator_provider: ILearningModelOperatorProvider) -> winsdk.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_stream(model_stream: winsdk.windows.storage.streams.IRandomAccessStreamReference) -> LearningModel: ...
    @typing.overload
    @staticmethod
    def load_from_stream(model_stream: winsdk.windows.storage.streams.IRandomAccessStreamReference, operator_provider: ILearningModelOperatorProvider) -> LearningModel: ...
    @typing.overload
    @staticmethod
    def load_from_stream_async(model_stream: winsdk.windows.storage.streams.IRandomAccessStreamReference) -> winsdk.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_stream_async(model_stream: winsdk.windows.storage.streams.IRandomAccessStreamReference, operator_provider: ILearningModelOperatorProvider) -> winsdk.windows.foundation.IAsyncOperation[LearningModel]: ...

class LearningModelBinding(winsdk.windows.foundation.collections.IMapView[str, _winrt.Object], winsdk.windows.foundation.collections.IIterable[winsdk.windows.foundation.collections.IKeyValuePair[str, _winrt.Object]], _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> LearningModelBinding: ...
    @typing.overload
    def __init__(self, session: LearningModelSession) -> None: ...
    @typing.overload
    def bind(self, name: str, value: _winrt.Object) -> None: ...
    @typing.overload
    def bind(self, name: str, value: _winrt.Object, props: winsdk.windows.foundation.collections.IPropertySet) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[winsdk.windows.foundation.collections.IKeyValuePair[str, _winrt.Object]]: ...
    @typing.overload
    def has_key(self, key: str) -> _winrt.Boolean: ...
    @typing.overload
    def lookup(self, key: str) -> _winrt.Object: ...
    @typing.overload
    def split(self, ) -> typing.Tuple[winsdk.windows.foundation.collections.IMapView[str, _winrt.Object], winsdk.windows.foundation.collections.IMapView[str, _winrt.Object]]: ...

class LearningModelDevice(_winrt.Object):
    adapter_id: winsdk.windows.graphics.DisplayAdapterId
    direct3_d11_device: winsdk.windows.graphics.directx.direct3d11.IDirect3DDevice
    @staticmethod
    def _from(obj: _winrt.Object) -> LearningModelDevice: ...
    @typing.overload
    def __init__(self, device_kind: LearningModelDeviceKind) -> None: ...
    @typing.overload
    @staticmethod
    def create_from_direct3_d11_device(device: winsdk.windows.graphics.directx.direct3d11.IDirect3DDevice) -> LearningModelDevice: ...

class LearningModelEvaluationResult(_winrt.Object):
    correlation_id: str
    error_status: _winrt.Int32
    outputs: winsdk.windows.foundation.collections.IMapView[str, _winrt.Object]
    succeeded: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> LearningModelEvaluationResult: ...

class LearningModelSession(winsdk.windows.foundation.IClosable, _winrt.Object):
    device: LearningModelDevice
    evaluation_properties: winsdk.windows.foundation.collections.IPropertySet
    model: LearningModel
    @staticmethod
    def _from(obj: _winrt.Object) -> LearningModelSession: ...
    @typing.overload
    def __init__(self, model: LearningModel, device_to_run_on: LearningModelDevice, learning_model_session_options: LearningModelSessionOptions) -> None: ...
    @typing.overload
    def __init__(self, model: LearningModel) -> None: ...
    @typing.overload
    def __init__(self, model: LearningModel, device_to_run_on: LearningModelDevice) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def evaluate(self, bindings: LearningModelBinding, correlation_id: str) -> LearningModelEvaluationResult: ...
    @typing.overload
    def evaluate_async(self, bindings: LearningModelBinding, correlation_id: str) -> winsdk.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    @typing.overload
    def evaluate_features(self, features: winsdk.windows.foundation.collections.IMap[str, _winrt.Object], correlation_id: str) -> LearningModelEvaluationResult: ...
    @typing.overload
    def evaluate_features_async(self, features: winsdk.windows.foundation.collections.IMap[str, _winrt.Object], correlation_id: str) -> winsdk.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]: ...

class LearningModelSessionOptions(_winrt.Object):
    batch_size_override: _winrt.UInt32
    close_model_on_session_creation: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> LearningModelSessionOptions: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def override_named_dimension(self, name: str, dimension: _winrt.UInt32) -> None: ...

class MapFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.Object):
    description: str
    is_required: _winrt.Boolean
    kind: LearningModelFeatureKind
    name: str
    key_kind: TensorKind
    value_descriptor: ILearningModelFeatureDescriptor
    @staticmethod
    def _from(obj: _winrt.Object) -> MapFeatureDescriptor: ...

class SequenceFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.Object):
    description: str
    is_required: _winrt.Boolean
    kind: LearningModelFeatureKind
    name: str
    element_descriptor: ILearningModelFeatureDescriptor
    @staticmethod
    def _from(obj: _winrt.Object) -> SequenceFeatureDescriptor: ...

class TensorBoolean(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorBoolean: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorBoolean: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorBoolean: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.Boolean]) -> TensorBoolean: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorBoolean: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.Boolean]) -> TensorBoolean: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.Boolean]) -> TensorBoolean: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.Boolean]: ...

class TensorDouble(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorDouble: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorDouble: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorDouble: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.Double]) -> TensorDouble: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorDouble: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.Double]) -> TensorDouble: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.Double]) -> TensorDouble: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.Double]: ...

class TensorFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.Object):
    description: str
    is_required: _winrt.Boolean
    kind: LearningModelFeatureKind
    name: str
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorFeatureDescriptor: ...

class TensorFloat(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorFloat: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorFloat: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorFloat: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.Single]) -> TensorFloat: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorFloat: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.Single]) -> TensorFloat: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.Single]) -> TensorFloat: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.Single]: ...

class TensorFloat16Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorFloat16Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorFloat16Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorFloat16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.Single]) -> TensorFloat16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorFloat16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.Single]) -> TensorFloat16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.Single]) -> TensorFloat16Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.Single]: ...

class TensorInt16Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorInt16Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorInt16Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.Int16]) -> TensorInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.Int16]) -> TensorInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.Int16]) -> TensorInt16Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.Int16]: ...

class TensorInt32Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorInt32Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorInt32Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.Int32]) -> TensorInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.Int32]) -> TensorInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.Int32]) -> TensorInt32Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.Int32]: ...

class TensorInt64Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorInt64Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorInt64Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.Int64]) -> TensorInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.Int64]) -> TensorInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.Int64]) -> TensorInt64Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]: ...

class TensorInt8Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorInt8Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorInt8Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.UInt8]) -> TensorInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.UInt8]) -> TensorInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.UInt8]) -> TensorInt8Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.UInt8]: ...

class TensorString(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorString: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorString: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorString: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[str]) -> TensorString: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[str]) -> TensorString: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[str]) -> TensorString: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[str]: ...

class TensorUInt16Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorUInt16Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorUInt16Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorUInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.UInt16]) -> TensorUInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorUInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.UInt16]) -> TensorUInt16Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.UInt16]) -> TensorUInt16Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.UInt16]: ...

class TensorUInt32Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorUInt32Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorUInt32Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorUInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.UInt32]) -> TensorUInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorUInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.UInt32]) -> TensorUInt32Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.UInt32]) -> TensorUInt32Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.UInt32]: ...

class TensorUInt64Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorUInt64Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorUInt64Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorUInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.UInt64]) -> TensorUInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorUInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.UInt64]) -> TensorUInt64Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.UInt64]) -> TensorUInt64Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.UInt64]: ...

class TensorUInt8Bit(ITensor, ILearningModelFeatureValue, winsdk.windows.foundation.IMemoryBuffer, winsdk.windows.foundation.IClosable, _winrt.Object):
    kind: LearningModelFeatureKind
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: _winrt.Object) -> TensorUInt8Bit: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> TensorUInt8Bit: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[_winrt.Int64]) -> TensorUInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_array(shape: typing.Iterable[_winrt.Int64], data: typing.Sequence[_winrt.UInt8]) -> TensorUInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_buffer(shape: typing.Sequence[_winrt.Int64], buffer: winsdk.windows.storage.streams.IBuffer) -> TensorUInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[_winrt.Int64], data: typing.Iterable[_winrt.UInt8]) -> TensorUInt8Bit: ...
    @typing.overload
    @staticmethod
    def create_from_shape_array_and_data_array(shape: typing.Sequence[_winrt.Int64], data: typing.Sequence[_winrt.UInt8]) -> TensorUInt8Bit: ...
    @typing.overload
    def create_reference(self) -> winsdk.windows.foundation.IMemoryBufferReference: ...
    @typing.overload
    def get_as_vector_view(self) -> winsdk.windows.foundation.collections.IVectorView[_winrt.UInt8]: ...

class ILearningModelFeatureDescriptor(_winrt.Object):
    description: str
    is_required: _winrt.Boolean
    kind: LearningModelFeatureKind
    name: str
    @staticmethod
    def _from(obj: _winrt.Object) -> ILearningModelFeatureDescriptor: ...

class ILearningModelFeatureValue(_winrt.Object):
    kind: LearningModelFeatureKind
    @staticmethod
    def _from(obj: _winrt.Object) -> ILearningModelFeatureValue: ...

class ILearningModelOperatorProvider(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ILearningModelOperatorProvider: ...

class ITensor(ILearningModelFeatureValue, _winrt.Object):
    shape: winsdk.windows.foundation.collections.IVectorView[_winrt.Int64]
    tensor_kind: TensorKind
    kind: LearningModelFeatureKind
    @staticmethod
    def _from(obj: _winrt.Object) -> ITensor: ...

