# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.2

import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt

try:
    import winsdk.windows.foundation
except Exception:
    pass

try:
    import winsdk.windows.foundation.collections
except Exception:
    pass

try:
    import winsdk.windows.globalization
except Exception:
    pass

try:
    import winsdk.windows.networking
except Exception:
    pass

try:
    import winsdk.windows.storage.streams
except Exception:
    pass

try:
    import winsdk.windows.web.http
except Exception:
    pass

class HttpCacheDirectiveHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpNameValueHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    shared_max_age: typing.Optional[winsdk.windows.foundation.TimeSpan]
    min_fresh: typing.Optional[winsdk.windows.foundation.TimeSpan]
    max_stale: typing.Optional[winsdk.windows.foundation.TimeSpan]
    max_age: typing.Optional[winsdk.windows.foundation.TimeSpan]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCacheDirectiveHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpNameValueHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpNameValueHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpNameValueHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpNameValueHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpNameValueHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpNameValueHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpNameValueHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpNameValueHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpNameValueHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpChallengeHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    parameters: winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    scheme: str
    token: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpChallengeHeaderValue: ...
    @typing.overload
    def __init__(self, scheme: str) -> None: ...
    @typing.overload
    def __init__(self, scheme: str, token: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpChallengeHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpChallengeHeaderValue]: ...

class HttpChallengeHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpChallengeHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpChallengeHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpChallengeHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpChallengeHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpChallengeHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpChallengeHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpChallengeHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpChallengeHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpChallengeHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpChallengeHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpChallengeHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpChallengeHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpConnectionOptionHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    token: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpConnectionOptionHeaderValue: ...
    @typing.overload
    def __init__(self, token: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpConnectionOptionHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpConnectionOptionHeaderValue]: ...

class HttpConnectionOptionHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpConnectionOptionHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpConnectionOptionHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpConnectionOptionHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpConnectionOptionHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpConnectionOptionHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpConnectionOptionHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpConnectionOptionHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpConnectionOptionHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpConnectionOptionHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpConnectionOptionHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpConnectionOptionHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpConnectionOptionHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpContentCodingHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    content_coding: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingHeaderValue: ...
    @typing.overload
    def __init__(self, content_coding: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpContentCodingHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpContentCodingHeaderValue]: ...

class HttpContentCodingHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpContentCodingHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpContentCodingHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpContentCodingHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpContentCodingHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpContentCodingHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpContentCodingHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpContentCodingHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpContentCodingHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpContentCodingHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpContentCodingHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpContentCodingHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpContentCodingWithQualityHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    content_coding: str
    quality: typing.Optional[_winrt.Double]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingWithQualityHeaderValue: ...
    @typing.overload
    def __init__(self, content_coding: str) -> None: ...
    @typing.overload
    def __init__(self, content_coding: str, quality: _winrt.Double) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpContentCodingWithQualityHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpContentCodingWithQualityHeaderValue]: ...

class HttpContentCodingWithQualityHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpContentCodingWithQualityHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpContentCodingWithQualityHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingWithQualityHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpContentCodingWithQualityHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpContentCodingWithQualityHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpContentCodingWithQualityHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpContentCodingWithQualityHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpContentCodingWithQualityHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpContentCodingWithQualityHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpContentCodingWithQualityHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpContentCodingWithQualityHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpContentCodingWithQualityHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpContentDispositionHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    size: typing.Optional[_winrt.UInt64]
    name: str
    file_name_star: str
    file_name: str
    disposition_type: str
    parameters: winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentDispositionHeaderValue: ...
    @typing.overload
    def __init__(self, disposition_type: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpContentDispositionHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpContentDispositionHeaderValue]: ...

class HttpContentHeaderCollection(winsdk.windows.foundation.collections.IMap[str, str], winsdk.windows.foundation.collections.IIterable[winsdk.windows.foundation.collections.IKeyValuePair[str, str]], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    last_modified: typing.Optional[winsdk.windows.foundation.DateTime]
    expires: typing.Optional[winsdk.windows.foundation.DateTime]
    content_type: HttpMediaTypeHeaderValue
    content_range: HttpContentRangeHeaderValue
    content_m_d5: winsdk.windows.storage.streams.IBuffer
    content_location: winsdk.windows.foundation.Uri
    content_length: typing.Optional[_winrt.UInt64]
    content_disposition: HttpContentDispositionHeaderValue
    content_encoding: HttpContentCodingHeaderValueCollection
    content_language: HttpLanguageHeaderValueCollection
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentHeaderCollection: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def append(self, name: str, value: str) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[winsdk.windows.foundation.collections.IKeyValuePair[str, str]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IMapView[str, str]: ...
    @typing.overload
    def has_key(self, key: str) -> _winrt.Boolean: ...
    @typing.overload
    def insert(self, key: str, value: str) -> _winrt.Boolean: ...
    @typing.overload
    def lookup(self, key: str) -> str: ...
    @typing.overload
    def remove(self, key: str) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_append_without_validation(self, name: str, value: str) -> _winrt.Boolean: ...

class HttpContentRangeHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    unit: str
    first_byte_position: typing.Optional[_winrt.UInt64]
    last_byte_position: typing.Optional[_winrt.UInt64]
    length: typing.Optional[_winrt.UInt64]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentRangeHeaderValue: ...
    @typing.overload
    def __init__(self, length: _winrt.UInt64) -> None: ...
    @typing.overload
    def __init__(self, from: _winrt.UInt64, to: _winrt.UInt64) -> None: ...
    @typing.overload
    def __init__(self, from: _winrt.UInt64, to: _winrt.UInt64, length: _winrt.UInt64) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpContentRangeHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpContentRangeHeaderValue]: ...

class HttpCookiePairHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    value: str
    name: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCookiePairHeaderValue: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpCookiePairHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpCookiePairHeaderValue]: ...

class HttpCookiePairHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpCookiePairHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpCookiePairHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCookiePairHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpCookiePairHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpCookiePairHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpCookiePairHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpCookiePairHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpCookiePairHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpCookiePairHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpCookiePairHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpCookiePairHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpCookiePairHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpCredentialsHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    parameters: winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    scheme: str
    token: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCredentialsHeaderValue: ...
    @typing.overload
    def __init__(self, scheme: str) -> None: ...
    @typing.overload
    def __init__(self, scheme: str, token: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpCredentialsHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpCredentialsHeaderValue]: ...

class HttpDateOrDeltaHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    date: typing.Optional[winsdk.windows.foundation.DateTime]
    delta: typing.Optional[winsdk.windows.foundation.TimeSpan]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpDateOrDeltaHeaderValue: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpDateOrDeltaHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpDateOrDeltaHeaderValue]: ...

class HttpExpectationHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    value: str
    name: str
    parameters: winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpExpectationHeaderValue: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpExpectationHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpExpectationHeaderValue]: ...

class HttpExpectationHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpExpectationHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpExpectationHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpExpectationHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpExpectationHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpExpectationHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpExpectationHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpExpectationHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpExpectationHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpExpectationHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpExpectationHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpExpectationHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpExpectationHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpLanguageHeaderValueCollection(winsdk.windows.foundation.collections.IVector[winsdk.windows.globalization.Language], winsdk.windows.foundation.collections.IIterable[winsdk.windows.globalization.Language], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpLanguageHeaderValueCollection: ...
    @typing.overload
    def append(self, value: winsdk.windows.globalization.Language) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[winsdk.windows.globalization.Language]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> winsdk.windows.globalization.Language: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[winsdk.windows.globalization.Language]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[winsdk.windows.globalization.Language]: ...
    @typing.overload
    def index_of(self, value: winsdk.windows.globalization.Language) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: winsdk.windows.globalization.Language) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[winsdk.windows.globalization.Language]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: winsdk.windows.globalization.Language) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpLanguageRangeWithQualityHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    language_range: str
    quality: typing.Optional[_winrt.Double]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpLanguageRangeWithQualityHeaderValue: ...
    @typing.overload
    def __init__(self, language_range: str) -> None: ...
    @typing.overload
    def __init__(self, language_range: str, quality: _winrt.Double) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpLanguageRangeWithQualityHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpLanguageRangeWithQualityHeaderValue]: ...

class HttpLanguageRangeWithQualityHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpLanguageRangeWithQualityHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpLanguageRangeWithQualityHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpLanguageRangeWithQualityHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpLanguageRangeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpLanguageRangeWithQualityHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpLanguageRangeWithQualityHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpLanguageRangeWithQualityHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpLanguageRangeWithQualityHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpLanguageRangeWithQualityHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpLanguageRangeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpLanguageRangeWithQualityHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpLanguageRangeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpMediaTypeHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    media_type: str
    char_set: str
    parameters: winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMediaTypeHeaderValue: ...
    @typing.overload
    def __init__(self, media_type: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpMediaTypeHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpMediaTypeHeaderValue]: ...

class HttpMediaTypeWithQualityHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    quality: typing.Optional[_winrt.Double]
    media_type: str
    char_set: str
    parameters: winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMediaTypeWithQualityHeaderValue: ...
    @typing.overload
    def __init__(self, media_type: str) -> None: ...
    @typing.overload
    def __init__(self, media_type: str, quality: _winrt.Double) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpMediaTypeWithQualityHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpMediaTypeWithQualityHeaderValue]: ...

class HttpMediaTypeWithQualityHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpMediaTypeWithQualityHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpMediaTypeWithQualityHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMediaTypeWithQualityHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpMediaTypeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpMediaTypeWithQualityHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpMediaTypeWithQualityHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpMediaTypeWithQualityHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpMediaTypeWithQualityHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpMediaTypeWithQualityHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpMediaTypeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpMediaTypeWithQualityHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpMediaTypeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpMethodHeaderValueCollection(winsdk.windows.foundation.collections.IVector[winsdk.windows.web.http.HttpMethod], winsdk.windows.foundation.collections.IIterable[winsdk.windows.web.http.HttpMethod], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMethodHeaderValueCollection: ...
    @typing.overload
    def append(self, value: winsdk.windows.web.http.HttpMethod) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[winsdk.windows.web.http.HttpMethod]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> winsdk.windows.web.http.HttpMethod: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[winsdk.windows.web.http.HttpMethod]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[winsdk.windows.web.http.HttpMethod]: ...
    @typing.overload
    def index_of(self, value: winsdk.windows.web.http.HttpMethod) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: winsdk.windows.web.http.HttpMethod) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[winsdk.windows.web.http.HttpMethod]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: winsdk.windows.web.http.HttpMethod) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpNameValueHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    value: str
    name: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpNameValueHeaderValue: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpNameValueHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpNameValueHeaderValue]: ...

class HttpProductHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    name: str
    version: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpProductHeaderValue: ...
    @typing.overload
    def __init__(self, product_name: str) -> None: ...
    @typing.overload
    def __init__(self, product_name: str, product_version: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpProductHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpProductHeaderValue]: ...

class HttpProductInfoHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    comment: str
    product: HttpProductHeaderValue
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpProductInfoHeaderValue: ...
    @typing.overload
    def __init__(self, product_comment: str) -> None: ...
    @typing.overload
    def __init__(self, product_name: str, product_version: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpProductInfoHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpProductInfoHeaderValue]: ...

class HttpProductInfoHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpProductInfoHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpProductInfoHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpProductInfoHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpProductInfoHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpProductInfoHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpProductInfoHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpProductInfoHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpProductInfoHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpProductInfoHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpProductInfoHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpProductInfoHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpProductInfoHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpRequestHeaderCollection(winsdk.windows.foundation.collections.IMap[str, str], winsdk.windows.foundation.collections.IIterable[winsdk.windows.foundation.collections.IKeyValuePair[str, str]], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    referer: winsdk.windows.foundation.Uri
    proxy_authorization: HttpCredentialsHeaderValue
    max_forwards: typing.Optional[_winrt.UInt32]
    if_unmodified_since: typing.Optional[winsdk.windows.foundation.DateTime]
    if_modified_since: typing.Optional[winsdk.windows.foundation.DateTime]
    host: winsdk.windows.networking.HostName
    from: str
    date: typing.Optional[winsdk.windows.foundation.DateTime]
    authorization: HttpCredentialsHeaderValue
    accept: HttpMediaTypeWithQualityHeaderValueCollection
    accept_encoding: HttpContentCodingWithQualityHeaderValueCollection
    accept_language: HttpLanguageRangeWithQualityHeaderValueCollection
    cache_control: HttpCacheDirectiveHeaderValueCollection
    connection: HttpConnectionOptionHeaderValueCollection
    cookie: HttpCookiePairHeaderValueCollection
    expect: HttpExpectationHeaderValueCollection
    transfer_encoding: HttpTransferCodingHeaderValueCollection
    user_agent: HttpProductInfoHeaderValueCollection
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpRequestHeaderCollection: ...
    @typing.overload
    def append(self, name: str, value: str) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[winsdk.windows.foundation.collections.IKeyValuePair[str, str]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IMapView[str, str]: ...
    @typing.overload
    def has_key(self, key: str) -> _winrt.Boolean: ...
    @typing.overload
    def insert(self, key: str, value: str) -> _winrt.Boolean: ...
    @typing.overload
    def lookup(self, key: str) -> str: ...
    @typing.overload
    def remove(self, key: str) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_append_without_validation(self, name: str, value: str) -> _winrt.Boolean: ...

class HttpResponseHeaderCollection(winsdk.windows.foundation.collections.IMap[str, str], winsdk.windows.foundation.collections.IIterable[winsdk.windows.foundation.collections.IKeyValuePair[str, str]], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    retry_after: HttpDateOrDeltaHeaderValue
    location: winsdk.windows.foundation.Uri
    date: typing.Optional[winsdk.windows.foundation.DateTime]
    age: typing.Optional[winsdk.windows.foundation.TimeSpan]
    allow: HttpMethodHeaderValueCollection
    cache_control: HttpCacheDirectiveHeaderValueCollection
    connection: HttpConnectionOptionHeaderValueCollection
    proxy_authenticate: HttpChallengeHeaderValueCollection
    transfer_encoding: HttpTransferCodingHeaderValueCollection
    www_authenticate: HttpChallengeHeaderValueCollection
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpResponseHeaderCollection: ...
    @typing.overload
    def append(self, name: str, value: str) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[winsdk.windows.foundation.collections.IKeyValuePair[str, str]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IMapView[str, str]: ...
    @typing.overload
    def has_key(self, key: str) -> _winrt.Boolean: ...
    @typing.overload
    def insert(self, key: str, value: str) -> _winrt.Boolean: ...
    @typing.overload
    def lookup(self, key: str) -> str: ...
    @typing.overload
    def remove(self, key: str) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_append_without_validation(self, name: str, value: str) -> _winrt.Boolean: ...

class HttpTransferCodingHeaderValue(winsdk.windows.foundation.IStringable, _winrt.Object):
    parameters: winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    value: str
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpTransferCodingHeaderValue: ...
    @typing.overload
    def __init__(self, input: str) -> None: ...
    @typing.overload
    @staticmethod
    def parse(input: str) -> HttpTransferCodingHeaderValue: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, HttpTransferCodingHeaderValue]: ...

class HttpTransferCodingHeaderValueCollection(winsdk.windows.foundation.collections.IVector[HttpTransferCodingHeaderValue], winsdk.windows.foundation.collections.IIterable[HttpTransferCodingHeaderValue], winsdk.windows.foundation.IStringable, _winrt.Object):
    size: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpTransferCodingHeaderValueCollection: ...
    @typing.overload
    def append(self, value: HttpTransferCodingHeaderValue) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def first(self) -> winsdk.windows.foundation.collections.IIterator[HttpTransferCodingHeaderValue]: ...
    @typing.overload
    def get_at(self, index: _winrt.UInt32) -> HttpTransferCodingHeaderValue: ...
    @typing.overload
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpTransferCodingHeaderValue]]: ...
    @typing.overload
    def get_view(self) -> winsdk.windows.foundation.collections.IVectorView[HttpTransferCodingHeaderValue]: ...
    @typing.overload
    def index_of(self, value: HttpTransferCodingHeaderValue) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    @typing.overload
    def insert_at(self, index: _winrt.UInt32, value: HttpTransferCodingHeaderValue) -> None: ...
    @typing.overload
    def parse_add(self, input: str) -> None: ...
    @typing.overload
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    @typing.overload
    def remove_at_end(self) -> None: ...
    @typing.overload
    def replace_all(self, items: typing.Sequence[HttpTransferCodingHeaderValue]) -> None: ...
    @typing.overload
    def set_at(self, index: _winrt.UInt32, value: HttpTransferCodingHeaderValue) -> None: ...
    @typing.overload
    def to_string(self) -> str: ...
    @typing.overload
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

