# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.2

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt

try:
    import winsdk.windows.applicationmodel
except Exception:
    pass

try:
    import winsdk.windows.foundation
except Exception:
    pass

try:
    import winsdk.windows.foundation.collections
except Exception:
    pass

try:
    import winsdk.windows.system
except Exception:
    pass

try:
    import winsdk.windows.web.http
except Exception:
    pass

class StoreCanLicenseStatus(enum.IntEnum):
    NOT_LICENSABLE_TO_USER = 0
    LICENSABLE = 1
    LICENSE_ACTION_NOT_APPLICABLE_TO_PRODUCT = 2
    NETWORK_ERROR = 3
    SERVER_ERROR = 4

class StoreConsumableStatus(enum.IntEnum):
    SUCCEEDED = 0
    INSUFFICENT_QUANTITY = 1
    NETWORK_ERROR = 2
    SERVER_ERROR = 3

class StoreDurationUnit(enum.IntEnum):
    MINUTE = 0
    HOUR = 1
    DAY = 2
    WEEK = 3
    MONTH = 4
    YEAR = 5

class StorePackageUpdateState(enum.IntEnum):
    PENDING = 0
    DOWNLOADING = 1
    DEPLOYING = 2
    COMPLETED = 3
    CANCELED = 4
    OTHER_ERROR = 5
    ERROR_LOW_BATTERY = 6
    ERROR_WI_FI_RECOMMENDED = 7
    ERROR_WI_FI_REQUIRED = 8

class StorePurchaseStatus(enum.IntEnum):
    SUCCEEDED = 0
    ALREADY_PURCHASED = 1
    NOT_PURCHASED = 2
    NETWORK_ERROR = 3
    SERVER_ERROR = 4

class StoreQueueItemExtendedState(enum.IntEnum):
    ACTIVE_PENDING = 0
    ACTIVE_STARTING = 1
    ACTIVE_ACQUIRING_LICENSE = 2
    ACTIVE_DOWNLOADING = 3
    ACTIVE_RESTORING_DATA = 4
    ACTIVE_INSTALLING = 5
    COMPLETED = 6
    CANCELED = 7
    PAUSED = 8
    ERROR = 9
    PAUSED_PACKAGES_IN_USE = 10
    PAUSED_LOW_BATTERY = 11
    PAUSED_WI_FI_RECOMMENDED = 12
    PAUSED_WI_FI_REQUIRED = 13
    PAUSED_READY_TO_INSTALL = 14

class StoreQueueItemKind(enum.IntEnum):
    INSTALL = 0
    UPDATE = 1
    REPAIR = 2

class StoreQueueItemState(enum.IntEnum):
    ACTIVE = 0
    COMPLETED = 1
    CANCELED = 2
    ERROR = 3
    PAUSED = 4

class StoreRateAndReviewStatus(enum.IntEnum):
    SUCCEEDED = 0
    CANCELED_BY_USER = 1
    NETWORK_ERROR = 2
    ERROR = 3

class StoreUninstallStorePackageStatus(enum.IntEnum):
    SUCCEEDED = 0
    CANCELED_BY_USER = 1
    NETWORK_ERROR = 2
    UNINSTALL_NOT_APPLICABLE = 3
    ERROR = 4

class StorePackageUpdateStatus:
    package_family_name: str
    package_download_size_in_bytes: _winrt.UInt64
    package_bytes_downloaded: _winrt.UInt64
    package_download_progress: _winrt.Double
    total_download_progress: _winrt.Double
    package_update_state: StorePackageUpdateState
    def __init__(self, package_family_name: str, package_download_size_in_bytes: _winrt.UInt64, package_bytes_downloaded: _winrt.UInt64, package_download_progress: _winrt.Double, total_download_progress: _winrt.Double, package_update_state: StorePackageUpdateState) -> None: ...

class StoreAcquireLicenseResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    store_package_license: StorePackageLicense
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreAcquireLicenseResult: ...

class StoreAppLicense(_winrt.Object):
    add_on_licenses: winsdk.windows.foundation.collections.IMapView[str, StoreLicense]
    expiration_date: winsdk.windows.foundation.DateTime
    extended_json_data: str
    is_active: _winrt.Boolean
    is_trial: _winrt.Boolean
    is_trial_owned_by_this_user: _winrt.Boolean
    sku_store_id: str
    trial_time_remaining: winsdk.windows.foundation.TimeSpan
    trial_unique_id: str
    is_disc_license: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreAppLicense: ...

class StoreAvailability(_winrt.Object):
    end_date: winsdk.windows.foundation.DateTime
    extended_json_data: str
    price: StorePrice
    store_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreAvailability: ...
    @typing.overload
    def request_purchase_async(self) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: StorePurchaseProperties) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreCanAcquireLicenseResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    licensable_sku: str
    status: StoreCanLicenseStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreCanAcquireLicenseResult: ...

class StoreCollectionData(_winrt.Object):
    acquired_date: winsdk.windows.foundation.DateTime
    campaign_id: str
    developer_offer_id: str
    end_date: winsdk.windows.foundation.DateTime
    extended_json_data: str
    is_trial: _winrt.Boolean
    start_date: winsdk.windows.foundation.DateTime
    trial_time_remaining: winsdk.windows.foundation.TimeSpan
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreCollectionData: ...

class StoreConsumableResult(_winrt.Object):
    balance_remaining: _winrt.UInt32
    extended_error: winsdk.windows.foundation.HResult
    status: StoreConsumableStatus
    tracking_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreConsumableResult: ...

class StoreContext(_winrt.Object):
    user: winsdk.windows.system.User
    can_silently_download_store_package_updates: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreContext: ...
    @typing.overload
    def acquire_store_license_for_optional_package_async(self, optional_package: winsdk.windows.applicationmodel.Package) -> winsdk.windows.foundation.IAsyncOperation[StoreAcquireLicenseResult]: ...
    @typing.overload
    def can_acquire_store_license_async(self, product_store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]: ...
    @typing.overload
    def can_acquire_store_license_for_optional_package_async(self, optional_package: winsdk.windows.applicationmodel.Package) -> winsdk.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]: ...
    @typing.overload
    def download_and_install_store_packages_async(self, store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def find_store_product_for_package_async(self, product_kinds: typing.Iterable[str], package: winsdk.windows.applicationmodel.Package) -> winsdk.windows.foundation.IAsyncOperation[StoreProductResult]: ...
    @typing.overload
    def get_app_and_optional_store_package_updates_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StorePackageUpdate]]: ...
    @typing.overload
    def get_app_license_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreAppLicense]: ...
    @typing.overload
    def get_associated_store_products_async(self, product_kinds: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    @typing.overload
    def get_associated_store_products_with_paging_async(self, product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: _winrt.UInt32) -> winsdk.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...
    @typing.overload
    def get_associated_store_queue_items_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    @typing.overload
    def get_consumable_balance_remaining_async(self, product_store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreConsumableResult]: ...
    @typing.overload
    def get_customer_collections_id_async(self, service_ticket: str, publisher_user_id: str) -> winsdk.windows.foundation.IAsyncOperation[str]: ...
    @typing.overload
    def get_customer_purchase_id_async(self, service_ticket: str, publisher_user_id: str) -> winsdk.windows.foundation.IAsyncOperation[str]: ...
    @typing.overload
    @staticmethod
    def get_default() -> StoreContext: ...
    @typing.overload
    @staticmethod
    def get_for_user(user: winsdk.windows.system.User) -> StoreContext: ...
    @typing.overload
    def get_store_product_for_current_app_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreProductResult]: ...
    @typing.overload
    def get_store_products_async(self, product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    @typing.overload
    def get_store_products_async(self, product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str], store_product_options: StoreProductOptions) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    @typing.overload
    def get_store_queue_items_async(self, store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    @typing.overload
    def get_user_collection_async(self, product_kinds: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    @typing.overload
    def get_user_collection_with_paging_async(self, product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: _winrt.UInt32) -> winsdk.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...
    @typing.overload
    def report_consumable_fulfillment_async(self, product_store_id: str, quantity: _winrt.UInt32, tracking_id: uuid.UUID) -> winsdk.windows.foundation.IAsyncOperation[StoreConsumableResult]: ...
    @typing.overload
    def request_download_and_install_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_download_and_install_store_packages_async(self, store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_download_and_install_store_packages_async(self, store_ids: typing.Iterable[str], store_package_install_options: StorePackageInstallOptions) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_download_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_purchase_async(self, store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_id: str, store_purchase_properties: StorePurchaseProperties) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_rate_and_review_app_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreRateAndReviewResult]: ...
    @typing.overload
    def request_uninstall_store_package_async(self, package: winsdk.windows.applicationmodel.Package) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    @typing.overload
    def request_uninstall_store_package_by_store_id_async(self, store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    @typing.overload
    def set_install_order_for_associated_store_queue_items_async(self, items: typing.Iterable[StoreQueueItem]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    @typing.overload
    def try_silent_download_and_install_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def try_silent_download_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def uninstall_store_package_async(self, package: winsdk.windows.applicationmodel.Package) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    @typing.overload
    def uninstall_store_package_by_store_id_async(self, store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    @typing.overload
    def add_offline_licenses_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[StoreContext, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    @typing.overload
    def remove_offline_licenses_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StoreImage(_winrt.Object):
    caption: str
    height: _winrt.UInt32
    image_purpose_tag: str
    uri: winsdk.windows.foundation.Uri
    width: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreImage: ...

class StoreLicense(_winrt.Object):
    expiration_date: winsdk.windows.foundation.DateTime
    extended_json_data: str
    in_app_offer_token: str
    is_active: _winrt.Boolean
    sku_store_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreLicense: ...

class StorePackageInstallOptions(_winrt.Object):
    allow_forced_app_restart: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageInstallOptions: ...
    @typing.overload
    def __init__(self) -> None: ...

class StorePackageLicense(winsdk.windows.foundation.IClosable, _winrt.Object):
    is_valid: _winrt.Boolean
    package: winsdk.windows.applicationmodel.Package
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageLicense: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def release_license(self) -> None: ...
    @typing.overload
    def add_license_lost(self, handler: winsdk.windows.foundation.TypedEventHandler[StorePackageLicense, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    @typing.overload
    def remove_license_lost(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StorePackageUpdate(_winrt.Object):
    mandatory: _winrt.Boolean
    package: winsdk.windows.applicationmodel.Package
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageUpdate: ...

class StorePackageUpdateResult(_winrt.Object):
    overall_state: StorePackageUpdateState
    store_package_update_statuses: winsdk.windows.foundation.collections.IVectorView[StorePackageUpdateStatus]
    store_queue_items: winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageUpdateResult: ...

class StorePrice(_winrt.Object):
    currency_code: str
    formatted_base_price: str
    formatted_price: str
    formatted_recurrence_price: str
    is_on_sale: _winrt.Boolean
    sale_end_date: winsdk.windows.foundation.DateTime
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePrice: ...

class StoreProduct(_winrt.Object):
    description: str
    extended_json_data: str
    has_digital_download: _winrt.Boolean
    images: winsdk.windows.foundation.collections.IVectorView[StoreImage]
    in_app_offer_token: str
    is_in_user_collection: _winrt.Boolean
    keywords: winsdk.windows.foundation.collections.IVectorView[str]
    language: str
    link_uri: winsdk.windows.foundation.Uri
    price: StorePrice
    product_kind: str
    skus: winsdk.windows.foundation.collections.IVectorView[StoreSku]
    store_id: str
    title: str
    videos: winsdk.windows.foundation.collections.IVectorView[StoreVideo]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProduct: ...
    @typing.overload
    def get_is_any_sku_installed_async(self) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...
    @typing.overload
    def request_purchase_async(self) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: StorePurchaseProperties) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreProductOptions(_winrt.Object):
    action_filters: winsdk.windows.foundation.collections.IVector[str]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductOptions: ...
    @typing.overload
    def __init__(self) -> None: ...

class StoreProductPagedQueryResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    has_more_results: _winrt.Boolean
    products: winsdk.windows.foundation.collections.IMapView[str, StoreProduct]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductPagedQueryResult: ...
    @typing.overload
    def get_next_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...

class StoreProductQueryResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    products: winsdk.windows.foundation.collections.IMapView[str, StoreProduct]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductQueryResult: ...

class StoreProductResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    product: StoreProduct
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductResult: ...

class StorePurchaseProperties(_winrt.Object):
    name: str
    extended_json_data: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePurchaseProperties: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class StorePurchaseResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    status: StorePurchaseStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePurchaseResult: ...

class StoreQueueItem(_winrt.Object):
    install_kind: StoreQueueItemKind
    package_family_name: str
    product_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreQueueItem: ...
    @typing.overload
    def cancel_install_async(self) -> winsdk.windows.foundation.IAsyncAction: ...
    @typing.overload
    def get_current_status(self) -> StoreQueueItemStatus: ...
    @typing.overload
    def pause_install_async(self) -> winsdk.windows.foundation.IAsyncAction: ...
    @typing.overload
    def resume_install_async(self) -> winsdk.windows.foundation.IAsyncAction: ...
    @typing.overload
    def add_completed(self, handler: winsdk.windows.foundation.TypedEventHandler[StoreQueueItem, StoreQueueItemCompletedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    @typing.overload
    def remove_completed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    @typing.overload
    def add_status_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[StoreQueueItem, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    @typing.overload
    def remove_status_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StoreQueueItemCompletedEventArgs(_winrt.Object):
    status: StoreQueueItemStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreQueueItemCompletedEventArgs: ...

class StoreQueueItemStatus(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    package_install_extended_state: StoreQueueItemExtendedState
    package_install_state: StoreQueueItemState
    update_status: StorePackageUpdateStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreQueueItemStatus: ...

class StoreRateAndReviewResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    extended_json_data: str
    status: StoreRateAndReviewStatus
    was_updated: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreRateAndReviewResult: ...

class StoreRequestHelper(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreRequestHelper: ...
    @typing.overload
    @staticmethod
    def send_request_async(context: StoreContext, request_kind: _winrt.UInt32, parameters_as_json: str) -> winsdk.windows.foundation.IAsyncOperation[StoreSendRequestResult]: ...

class StoreSendRequestResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    response: str
    http_status_code: winsdk.windows.web.http.HttpStatusCode
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreSendRequestResult: ...

class StoreSku(_winrt.Object):
    availabilities: winsdk.windows.foundation.collections.IVectorView[StoreAvailability]
    bundled_skus: winsdk.windows.foundation.collections.IVectorView[str]
    collection_data: StoreCollectionData
    custom_developer_data: str
    description: str
    extended_json_data: str
    images: winsdk.windows.foundation.collections.IVectorView[StoreImage]
    is_in_user_collection: _winrt.Boolean
    is_subscription: _winrt.Boolean
    is_trial: _winrt.Boolean
    language: str
    price: StorePrice
    store_id: str
    subscription_info: StoreSubscriptionInfo
    title: str
    videos: winsdk.windows.foundation.collections.IVectorView[StoreVideo]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreSku: ...
    @typing.overload
    def get_is_installed_async(self) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...
    @typing.overload
    def request_purchase_async(self) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: StorePurchaseProperties) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreSubscriptionInfo(_winrt.Object):
    billing_period: _winrt.UInt32
    billing_period_unit: StoreDurationUnit
    has_trial_period: _winrt.Boolean
    trial_period: _winrt.UInt32
    trial_period_unit: StoreDurationUnit
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreSubscriptionInfo: ...

class StoreUninstallStorePackageResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    status: StoreUninstallStorePackageStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreUninstallStorePackageResult: ...

class StoreVideo(_winrt.Object):
    caption: str
    height: _winrt.UInt32
    preview_image: StoreImage
    uri: winsdk.windows.foundation.Uri
    video_purpose_tag: str
    width: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreVideo: ...

