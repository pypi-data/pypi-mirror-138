# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['rest_live']

package_data = \
{'': ['*']}

install_requires = \
['Django>=3.1', 'channels>=2.0.0', 'djangorestframework>=3.11']

setup_kwargs = {
    'name': 'django-rest-live',
    'version': '0.7.0',
    'description': 'Subscriptions for Django REST Framework over Websockets.',
    'long_description': '## Django REST Live\n\n[![Documentation](https://readthedocs.org/projects/django-rest-live/badge/?version=latest)](https://django-rest-live.readthedocs.io/en/latest/?badge=latest)\n[![CircleCI](https://circleci.com/gh/pennlabs/django-rest-live.svg?style=shield)](https://circleci.com/gh/pennlabs/django-rest-live)\n[![Coverage Status](https://codecov.io/gh/pennlabs/django-rest-live/branch/master/graph/badge.svg)](https://codecov.io/gh/pennlabs/django-rest-live)\n[![PyPi Package](https://img.shields.io/pypi/v/django-rest-live.svg)](https://pypi.org/project/django-rest-live/)\n\nDjango REST Live enables clients which use an API built with [Django REST Framework](https://github.com/encode/django-rest-framework) to receive a stream of updates for querysets and model instances over a websocket connection managed by [Django Channels](https://github.com/django/channels). There had been plans for real-time websocket support in REST Framework on a few occasions ([2016](https://www.django-rest-framework.org/community/mozilla-grant/#realtime-apis), [2018](https://groups.google.com/g/django-rest-framework/c/3-QNn3SYlZI/m/Gwx6rFr4BQAJ?pli=1)), but at the time, async support in Django was in the early planning stages and Channels was being [rewritten with breaking API changes](https://channels.readthedocs.io/en/2.x/one-to-two.html).\n\nThis plugin aims to bridge that gap between Channels and REST Framework while being as generic and boilerplate-free as possible. Clients are be able to subscribe to real-time updates for any queryset that\'s exposed through a [Generic API View](https://www.django-rest-framework.org/api-guide/generic-views/#genericapiview) or any of its subclasses, including [Model ViewSet](https://www.django-rest-framework.org/api-guide/viewsets/#modelviewset), with just one mixin!\n\nCheck out [the full tutorial and reference documentation](https://django-rest-live.readthedocs.io) for specifics.\n\n### Dependencies\n\n- [Django](https://github.com/django/django/) (3.1 and up)\n- [Django Channels](https://github.com/django/channels) (2.x and 3.x both supported)\n- [Django REST Framework](https://github.com/encode/django-rest-framework/) (3.11 and up)\n- [`channels_redis`](https://github.com/django/channels_redis) for\n  [channel layer](https://channels.readthedocs.io/en/latest/topics/channel_layers.html) support in production. Channel layers is what allows a Django signal to broadcast an update to all websocket clients.\n\n### Installation and Setup\n\nMake sure to [install and properly set up Django Channels](https://channels.readthedocs.io/en/latest/installation.html) before installing `django-rest-live`.\n\n```\npip install django-rest-live\n```\n\nAdd `rest_live` to your `INSTALLED_APPS`:\n\n```python\nINSTALLED_APPS = [\n    ...\n    "rest_framework",\n    "channels",\n    "rest_live",\n]\n```\n\nCreate a `RealtimeRouter` in your ASGI routing file (generally `asgi.py`) and add the router\'s consumer to the websocket routing you set up with Django Channels. Feel free to choose any URL endpoint for the websocket, here we\'ve chosen `/ws/subscribe/`.\n\n```python\nfrom channels.auth import AuthMiddlewareStack\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom django.urls import path\nfrom django.core.asgi import get_asgi_application\nfrom rest_live.routers import RealtimeRouter\n\nrouter = RealtimeRouter()\n\napplication = ProtocolTypeRouter({\n    "http": get_asgi_application(),\n    "websocket": AuthMiddlewareStack(\n    URLRouter([\n        path("ws/subscribe/", router.as_consumer().as_asgi(), name="subscriptions"),\n    ])\n),\n})\n```\n\n### Configuration\n\n> Check out the [Tutorial](https://django-rest-live.readthedocs.io/en/latest/usage/) for an in-depth example.\n\nTo allow subscriptions to a queryset, add the `RealtimeMixin` to a GenericAPIView or ModelViewSet that exposes that queryset. Then, register the view with the `RealtimeRouter` instance you created during setup.\n\n```python\n...\nrouter = RealtimeRouter()\nrouter.register(MyViewSet)  # Register all ViewSets here\n...\n```\n\n### Client-Side\n\nSubscribing to a updates equires opening a [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\non the client connection to the URL you specified during setup. Feel free to use any frontend web framework you\'d like. Below is a simple example in vanilla JavaScript which logs updates to the console.\n\n```javascript\nconst socket = new WebSocket("ws://<django_domain_here>/ws/subscribe");\n\nsocket.addEventListener("message", function (event) {\n  console.log("Update received:", JSON.parse(event.data));\n});\n\n// Subscribe to updates for the model instance with the ID of 1.\nsocket.send(\n  JSON.stringify({\n    id: 1337,\n    type: "subscribe",\n    model: "appname.ModelName",\n    action: "retrieve",\n    lookup_by: 1,\n  })\n);\n\n// Subscribe to updates for every model in the queryset.\nsocket.send(\n  JSON.stringify({\n    id: 1338,\n    type: "subscribe",\n    model: "appname.ModelName",\n    action: "list",\n  })\n);\n\n// After 5 seconds, unsubscribe from updates for the single model instance with ID 1.\nsetTimeout(5 * 1000, () =>\n  socket.sent(\n    JSON.stringify({\n      type: "unsubscribe",\n      id: 1337,\n    })\n  )\n);\n```\n\nBroadcast updates will be sent from the server in this format:\n\n```json\n{\n  "type": "broadcast",\n  "id": 1337,\n  "model": "appname.ModelName",\n  "action": "UPDATED",\n  "instance": { "id": 1, "field1": "value1", "field2": "value2" }\n}\n```\n\nThis is only a basic example. For more details, including how to send arguments and parameters along with subscriptions, read the [Tutorial](https://django-rest-live.readthedocs.io/en/latest/usage/) and the [Websocket API Reference](https://django-rest-live.readthedocs.io/en/latest/api/).\n\n### Closing Notes\n\n`django-rest-live` took initial inspiration from [this article by Kit La Touche](https://www.oddbird.net/2018/12/12/channels-and-drf/).\nDifferently from projects like [`djangochannelsrestframework`](https://github.com/hishnash/djangochannelsrestframework),\n`django-rest-live` does not aim to supplant REST Framework for performing CRUD actions through a REST API. Instead,\nit is designed to be used in conjunction with HTTP REST endpoints. Clients should still use normal REST framework\nendpoints generated by ViewSets and other API views to get initial data to populate a page, as well as any write-driven\nbehavior (`POST`, `PATCH`, `PUT`, `DELETE`). `django-rest-live` gets rid of the need for periodic polling GET\nrequests to for resource updates after page load.\n',
    'author': 'Penn Labs',
    'author_email': 'contact@pennlabs.org',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/pennlabs/django-rest-live',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7',
}


setup(**setup_kwargs)
