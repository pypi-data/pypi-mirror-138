"""
data model for engraver score.
tools to import and convert score from/to json/dict
"""

from enum import Enum, auto
from typing import List, Literal, Optional, Union

import qahirah as qah
from pydantic import BaseModel, Field
from pydantic.color import Color
from typing_extensions import Annotated


def _transform_underscores_to_dashes(string: str) -> str:
    return string.replace("_", "-")


class LowercaseString(Enum):
    def _generate_next_value_(name, start, count, last_values):
        return name.lower()


class Strings(LowercaseString):
    """
    String constants.
    Lowercase values are autogenerated and assigned;
    can be accessed like Strings.LINE.value
    """

    LINE = auto()
    TEXT = auto()
    ELEMENT = auto()


class LineCoords(BaseModel):
    x1: float
    y1: float
    x2: float
    y2: float


class LineCap(LowercaseString):
    BUTT = auto()
    ROUND = auto()
    SQUARE = auto()

    def get_cairo_value(self):
        match self:
            case LineCap.BUTT:
                return qah.CAIRO.LINE_CAP_BUTT
            case LineCap.ROUND:
                return qah.CAIRO.LINE_CAP_ROUND
            case LineCap.SQUARE:
                return qah.CAIRO.LINE_CAP_SQUARE


class FontStyle(LowercaseString):
    NORMAL = auto()
    ITALIC = auto()
    OBLIQUE = auto()

    def get_cairo_value(self):
        match self:
            case FontStyle.NORMAL:
                return qah.CAIRO.FONT_SLANT_NORMAL
            case FontStyle.ITALIC:
                return qah.CAIRO.FONT_SLANT_ITALIC
            case FontStyle.OBLIQUE:
                return qah.CAIRO.FONT_SLANT_OBLIQUE


class FontWeight(LowercaseString):
    NORMAL = auto()
    BOLD = auto()
    # TODO: add support for weight numbers like 100, 400, ...

    def get_cairo_value(self):
        match self:
            case FontWeight.NORMAL:
                return qah.CAIRO.FONT_WEIGHT_NORMAL
            case FontWeight.BOLD:
                return qah.CAIRO.FONT_WEIGHT_BOLD


class TextAnchor(LowercaseString):
    START = auto()
    MIDDLE = auto()
    END = auto()


class Point(BaseModel):
    x: float
    y: float


class Page(BaseModel):
    width: float
    height: float


class Style(BaseModel):
    """
    naming of params based on SVG Styling properties.
    ref: https://www.w3.org/TR/SVG11/styling.html#SVGStylingProperties

    python class field names are underscore separated,
    dict/json properties are to be dash separated, as in CSS/SVG.
    """

    stroke: Optional[Color]
    stroke_width: Optional[float]
    stroke_dasharray: Optional[List[float]]
    stroke_dashoffset: Optional[float]
    stroke_linecap: Optional[LineCap]
    # stroke_linejoin: Optional[LineJoin] # miter/round/bevel
    # stroke_miterlimit: Optional[float]

    fill: Optional[Color]

    font_family: Optional[str]
    font_style: Optional[FontStyle]
    font_weight: Optional[FontWeight]
    font_size: Optional[float]
    text_anchor: Optional[TextAnchor]

    class Config:
        # to convert stroke_width to stroke-width etc.
        alias_generator = _transform_underscores_to_dashes
        # to make Config(stroke_width=...) also work
        allow_population_by_field_name = True

        # it's easy to make errors in json/dict while filling style details.
        # forbidding unknown/unsupported/typo properties is a good approach.
        extra = "forbid"


class Line(BaseModel):
    element: Literal[Strings.LINE.value] = Strings.LINE.value
    id: Optional[str]
    coords: LineCoords
    style: Style


class Text(BaseModel):
    element: Literal[Strings.TEXT.value] = Strings.TEXT.value
    id: Optional[str]
    text: str
    coords: Point
    style: Style


Element = Annotated[Union[Line, Text], Field(discriminator=Strings.ELEMENT.value)]


class Score(BaseModel):
    page: Page
    file: str
    draw: List[Element]


def from_dict(score_dict: dict) -> Score:
    """score_dict should follow the json schema defined here"""
    return Score(**score_dict)


def from_json_str(score_json: str) -> Score:
    """score_json should be json following the schema defined here"""
    import json

    score_dict = json.loads(score_json)
    return Score(**score_dict)


def from_json_file(score_json_file) -> Score:
    import json

    score_dict = None
    with open(score_json_file) as f:
        score_dict = json.load(f)

    return Score(**score_dict)
